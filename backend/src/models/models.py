# -*- coding: utf-8 -*-
# code generated by Prisma. DO NOT EDIT.
# pyright: reportUnusedImport=false
# fmt: off

# global imports for type checking
from builtins import bool as _bool
from builtins import int as _int
from builtins import float as _float
from builtins import str as _str
import sys
import decimal
import datetime
from typing import (
    TYPE_CHECKING,
    Optional,
    Iterable,
    Iterator,
    Sequence,
    Callable,
    ClassVar,
    NoReturn,
    TypeVar,
    Generic,
    Mapping,
    Tuple,
    Union,
    List,
    Dict,
    Type,
    Any,
    Set,
    overload,
    cast,
)
from typing_extensions import TypedDict, Literal


LiteralString = str
# -- template models.py.jinja --
import os
import logging
import inspect
import warnings
from collections import OrderedDict

from pydantic import BaseModel, Field

from . import types, enums, errors, fields, bases
from ._types import FuncType
from ._compat import model_rebuild, field_validator
from ._builder import serialize_base64
from .generator import partial_models_ctx, PartialModelField


log: logging.Logger = logging.getLogger(__name__)
_created_partial_types: Set[str] = set()

class User(bases.BaseUser):
    """Represents a User record"""

    id: _str
    email: _str
    name: Optional[_str] = None
    image: Optional[_str] = None
    role: 'enums.UserRole'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    facebookId: Optional[_str] = None
    facebookToken: Optional[_str] = None
    facebookTokenExpiry: Optional[datetime.datetime] = None
    facebookPages: Optional[List['models.FacebookPage']] = None
    whatsappNumbers: Optional[List['models.WhatsappNumber']] = None
    leads: Optional[List['models.Lead']] = None
    campaigns: Optional[List['models.Campaign']] = None
    auditLogs: Optional[List['models.AuditLog']] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.UserKeys']] = None,
        exclude: Optional[Iterable['types.UserKeys']] = None,
        required: Optional[Iterable['types.UserKeys']] = None,
        optional: Optional[Iterable['types.UserKeys']] = None,
        relations: Optional[Mapping['types.UserRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.UserKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _User_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _User_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _User_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _User_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _User_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _User_relational_fields:
                        raise errors.UnknownRelationalFieldError('User', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid User / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'User',
            }
        )
        _created_partial_types.add(name)


class FacebookPage(bases.BaseFacebookPage):
    """Represents a FacebookPage record"""

    id: _str
    facebookPageId: _str
    name: _str
    accessToken: _str
    tokenExpiry: Optional[datetime.datetime] = None
    isActive: _bool
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    userId: _str
    user: Optional['models.User'] = None
    posts: Optional[List['models.FacebookPost']] = None
    leads: Optional[List['models.Lead']] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.FacebookPageKeys']] = None,
        exclude: Optional[Iterable['types.FacebookPageKeys']] = None,
        required: Optional[Iterable['types.FacebookPageKeys']] = None,
        optional: Optional[Iterable['types.FacebookPageKeys']] = None,
        relations: Optional[Mapping['types.FacebookPageRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.FacebookPageKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _FacebookPage_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _FacebookPage_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _FacebookPage_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _FacebookPage_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _FacebookPage_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _FacebookPage_relational_fields:
                        raise errors.UnknownRelationalFieldError('FacebookPage', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid FacebookPage / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'FacebookPage',
            }
        )
        _created_partial_types.add(name)


class FacebookPost(bases.BaseFacebookPost):
    """Represents a FacebookPost record"""

    id: _str
    facebookPostId: _str
    message: Optional[_str] = None
    story: Optional[_str] = None
    createdTime: datetime.datetime
    likesCount: _int
    commentsCount: _int
    sharesCount: _int
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    facebookPageId: _str
    facebookPage: Optional['models.FacebookPage'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.FacebookPostKeys']] = None,
        exclude: Optional[Iterable['types.FacebookPostKeys']] = None,
        required: Optional[Iterable['types.FacebookPostKeys']] = None,
        optional: Optional[Iterable['types.FacebookPostKeys']] = None,
        relations: Optional[Mapping['types.FacebookPostRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.FacebookPostKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _FacebookPost_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _FacebookPost_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _FacebookPost_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _FacebookPost_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _FacebookPost_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _FacebookPost_relational_fields:
                        raise errors.UnknownRelationalFieldError('FacebookPost', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid FacebookPost / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'FacebookPost',
            }
        )
        _created_partial_types.add(name)


class WhatsappNumber(bases.BaseWhatsappNumber):
    """Represents a WhatsappNumber record"""

    id: _str
    phoneNumber: _str
    displayName: Optional[_str] = None
    businessAccountId: _str
    accessToken: _str
    isActive: _bool
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    userId: _str
    user: Optional['models.User'] = None
    templates: Optional[List['models.WhatsappTemplate']] = None
    messages: Optional[List['models.Message']] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.WhatsappNumberKeys']] = None,
        exclude: Optional[Iterable['types.WhatsappNumberKeys']] = None,
        required: Optional[Iterable['types.WhatsappNumberKeys']] = None,
        optional: Optional[Iterable['types.WhatsappNumberKeys']] = None,
        relations: Optional[Mapping['types.WhatsappNumberRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.WhatsappNumberKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _WhatsappNumber_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _WhatsappNumber_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _WhatsappNumber_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _WhatsappNumber_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _WhatsappNumber_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _WhatsappNumber_relational_fields:
                        raise errors.UnknownRelationalFieldError('WhatsappNumber', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid WhatsappNumber / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'WhatsappNumber',
            }
        )
        _created_partial_types.add(name)


class WhatsappTemplate(bases.BaseWhatsappTemplate):
    """Represents a WhatsappTemplate record"""

    id: _str
    name: _str
    language: _str
    status: _str
    category: _str
    components: 'fields.Json'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    whatsappNumberId: _str
    whatsappNumber: Optional['models.WhatsappNumber'] = None
    messages: Optional[List['models.Message']] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.WhatsappTemplateKeys']] = None,
        exclude: Optional[Iterable['types.WhatsappTemplateKeys']] = None,
        required: Optional[Iterable['types.WhatsappTemplateKeys']] = None,
        optional: Optional[Iterable['types.WhatsappTemplateKeys']] = None,
        relations: Optional[Mapping['types.WhatsappTemplateRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.WhatsappTemplateKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _WhatsappTemplate_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _WhatsappTemplate_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _WhatsappTemplate_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _WhatsappTemplate_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _WhatsappTemplate_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _WhatsappTemplate_relational_fields:
                        raise errors.UnknownRelationalFieldError('WhatsappTemplate', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid WhatsappTemplate / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'WhatsappTemplate',
            }
        )
        _created_partial_types.add(name)


class Lead(bases.BaseLead):
    """Represents a Lead record"""

    id: _str
    firstName: Optional[_str] = None
    lastName: Optional[_str] = None
    email: Optional[_str] = None
    phoneNumber: Optional[_str] = None
    facebookUserId: Optional[_str] = None
    source: 'enums.LeadSource'
    status: 'enums.LeadStatus'
    consentGiven: _bool
    consentTimestamp: Optional[datetime.datetime] = None
    consentType: Optional['enums.ConsentType'] = None
    lastInteraction: Optional[datetime.datetime] = None
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    userId: _str
    user: Optional['models.User'] = None
    facebookPageId: Optional[_str] = None
    facebookPage: Optional['models.FacebookPage'] = None
    tags: Optional[List['models.LeadTag']] = None
    messages: Optional[List['models.Message']] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.LeadKeys']] = None,
        exclude: Optional[Iterable['types.LeadKeys']] = None,
        required: Optional[Iterable['types.LeadKeys']] = None,
        optional: Optional[Iterable['types.LeadKeys']] = None,
        relations: Optional[Mapping['types.LeadRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.LeadKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Lead_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Lead_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Lead_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Lead_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _Lead_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _Lead_relational_fields:
                        raise errors.UnknownRelationalFieldError('Lead', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Lead / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Lead',
            }
        )
        _created_partial_types.add(name)


class Tag(bases.BaseTag):
    """Represents a Tag record"""

    id: _str
    name: _str
    color: Optional[_str] = None
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    leads: Optional[List['models.LeadTag']] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.TagKeys']] = None,
        exclude: Optional[Iterable['types.TagKeys']] = None,
        required: Optional[Iterable['types.TagKeys']] = None,
        optional: Optional[Iterable['types.TagKeys']] = None,
        relations: Optional[Mapping['types.TagRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.TagKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Tag_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Tag_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Tag_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Tag_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _Tag_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _Tag_relational_fields:
                        raise errors.UnknownRelationalFieldError('Tag', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Tag / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Tag',
            }
        )
        _created_partial_types.add(name)


class LeadTag(bases.BaseLeadTag):
    """Represents a LeadTag record"""

    leadId: _str
    tagId: _str
    createdAt: datetime.datetime
    lead: Optional['models.Lead'] = None
    tag: Optional['models.Tag'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.LeadTagKeys']] = None,
        exclude: Optional[Iterable['types.LeadTagKeys']] = None,
        required: Optional[Iterable['types.LeadTagKeys']] = None,
        optional: Optional[Iterable['types.LeadTagKeys']] = None,
        relations: Optional[Mapping['types.LeadTagRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.LeadTagKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _LeadTag_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _LeadTag_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _LeadTag_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _LeadTag_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _LeadTag_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _LeadTag_relational_fields:
                        raise errors.UnknownRelationalFieldError('LeadTag', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid LeadTag / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'LeadTag',
            }
        )
        _created_partial_types.add(name)


class Message(bases.BaseMessage):
    """Represents a Message record"""

    id: _str
    type: 'enums.MessageType'
    platform: 'enums.MessagePlatform'
    recipient: _str
    content: _str
    status: 'enums.MessageStatus'
    sentAt: Optional[datetime.datetime] = None
    deliveredAt: Optional[datetime.datetime] = None
    readAt: Optional[datetime.datetime] = None
    errorMessage: Optional[_str] = None
    retryCount: _int
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    leadId: Optional[_str] = None
    lead: Optional['models.Lead'] = None
    campaignId: Optional[_str] = None
    campaign: Optional['models.Campaign'] = None
    whatsappNumberId: Optional[_str] = None
    whatsappNumber: Optional['models.WhatsappNumber'] = None
    whatsappTemplateId: Optional[_str] = None
    whatsappTemplate: Optional['models.WhatsappTemplate'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.MessageKeys']] = None,
        exclude: Optional[Iterable['types.MessageKeys']] = None,
        required: Optional[Iterable['types.MessageKeys']] = None,
        optional: Optional[Iterable['types.MessageKeys']] = None,
        relations: Optional[Mapping['types.MessageRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.MessageKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Message_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Message_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Message_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Message_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _Message_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _Message_relational_fields:
                        raise errors.UnknownRelationalFieldError('Message', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Message / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Message',
            }
        )
        _created_partial_types.add(name)


class Campaign(bases.BaseCampaign):
    """Represents a Campaign record"""

    id: _str
    name: _str
    description: Optional[_str] = None
    type: 'enums.CampaignType'
    status: 'enums.CampaignStatus'
    scheduledAt: Optional[datetime.datetime] = None
    startedAt: Optional[datetime.datetime] = None
    completedAt: Optional[datetime.datetime] = None
    targetAudience: 'fields.Json'
    messageTemplate: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    userId: _str
    user: Optional['models.User'] = None
    messages: Optional[List['models.Message']] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.CampaignKeys']] = None,
        exclude: Optional[Iterable['types.CampaignKeys']] = None,
        required: Optional[Iterable['types.CampaignKeys']] = None,
        optional: Optional[Iterable['types.CampaignKeys']] = None,
        relations: Optional[Mapping['types.CampaignRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.CampaignKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Campaign_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Campaign_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Campaign_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Campaign_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _Campaign_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _Campaign_relational_fields:
                        raise errors.UnknownRelationalFieldError('Campaign', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Campaign / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Campaign',
            }
        )
        _created_partial_types.add(name)


class AuditLog(bases.BaseAuditLog):
    """Represents a AuditLog record"""

    id: _str
    action: _str
    resource: _str
    resourceId: Optional[_str] = None
    details: Optional['fields.Json'] = None
    ipAddress: Optional[_str] = None
    userAgent: Optional[_str] = None
    createdAt: datetime.datetime
    userId: Optional[_str] = None
    user: Optional['models.User'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.AuditLogKeys']] = None,
        exclude: Optional[Iterable['types.AuditLogKeys']] = None,
        required: Optional[Iterable['types.AuditLogKeys']] = None,
        optional: Optional[Iterable['types.AuditLogKeys']] = None,
        relations: Optional[Mapping['types.AuditLogRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.AuditLogKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _AuditLog_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _AuditLog_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _AuditLog_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _AuditLog_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _AuditLog_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _AuditLog_relational_fields:
                        raise errors.UnknownRelationalFieldError('AuditLog', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid AuditLog / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'AuditLog',
            }
        )
        _created_partial_types.add(name)


class ApiKey(bases.BaseApiKey):
    """Represents a ApiKey record"""

    id: _str
    name: _str
    keyHash: _str
    permissions: 'fields.Json'
    isActive: _bool
    lastUsedAt: Optional[datetime.datetime] = None
    expiresAt: Optional[datetime.datetime] = None
    createdAt: datetime.datetime
    updatedAt: datetime.datetime

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.ApiKeyKeys']] = None,
        exclude: Optional[Iterable['types.ApiKeyKeys']] = None,
        required: Optional[Iterable['types.ApiKeyKeys']] = None,
        optional: Optional[Iterable['types.ApiKeyKeys']] = None,
        relations: Optional[Mapping['types.ApiKeyRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.ApiKeyKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _ApiKey_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _ApiKey_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _ApiKey_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _ApiKey_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True


            if relations:
                raise ValueError('Model: "ApiKey" has no relational fields.')
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid ApiKey / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'ApiKey',
            }
        )
        _created_partial_types.add(name)


class RateLimit(bases.BaseRateLimit):
    """Represents a RateLimit record"""

    id: _str
    identifier: _str
    endpoint: _str
    requestCount: _int
    windowStart: datetime.datetime
    createdAt: datetime.datetime
    updatedAt: datetime.datetime

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.RateLimitKeys']] = None,
        exclude: Optional[Iterable['types.RateLimitKeys']] = None,
        required: Optional[Iterable['types.RateLimitKeys']] = None,
        optional: Optional[Iterable['types.RateLimitKeys']] = None,
        relations: Optional[Mapping['types.RateLimitRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.RateLimitKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _RateLimit_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _RateLimit_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _RateLimit_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _RateLimit_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True


            if relations:
                raise ValueError('Model: "RateLimit" has no relational fields.')
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid RateLimit / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'RateLimit',
            }
        )
        _created_partial_types.add(name)



_User_relational_fields: Set[str] = {
        'facebookPages',
        'whatsappNumbers',
        'leads',
        'campaigns',
        'auditLogs',
    }
_User_fields: Dict['types.UserKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('email', {
            'name': 'email',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('name', {
            'name': 'name',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('image', {
            'name': 'image',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('role', {
            'name': 'role',
            'is_list': False,
            'optional': False,
            'type': 'enums.UserRole',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('facebookId', {
            'name': 'facebookId',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('facebookToken', {
            'name': 'facebookToken',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('facebookTokenExpiry', {
            'name': 'facebookTokenExpiry',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('facebookPages', {
            'name': 'facebookPages',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.FacebookPage\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('whatsappNumbers', {
            'name': 'whatsappNumbers',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.WhatsappNumber\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('leads', {
            'name': 'leads',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Lead\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('campaigns', {
            'name': 'campaigns',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Campaign\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('auditLogs', {
            'name': 'auditLogs',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.AuditLog\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_FacebookPage_relational_fields: Set[str] = {
        'user',
        'posts',
        'leads',
    }
_FacebookPage_fields: Dict['types.FacebookPageKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('facebookPageId', {
            'name': 'facebookPageId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('name', {
            'name': 'name',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('accessToken', {
            'name': 'accessToken',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('tokenExpiry', {
            'name': 'tokenExpiry',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('isActive', {
            'name': 'isActive',
            'is_list': False,
            'optional': False,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('userId', {
            'name': 'userId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('user', {
            'name': 'user',
            'is_list': False,
            'optional': True,
            'type': 'models.User',
            'is_relational': True,
            'documentation': None,
        }),
        ('posts', {
            'name': 'posts',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.FacebookPost\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('leads', {
            'name': 'leads',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Lead\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_FacebookPost_relational_fields: Set[str] = {
        'facebookPage',
    }
_FacebookPost_fields: Dict['types.FacebookPostKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('facebookPostId', {
            'name': 'facebookPostId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('message', {
            'name': 'message',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('story', {
            'name': 'story',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdTime', {
            'name': 'createdTime',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('likesCount', {
            'name': 'likesCount',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('commentsCount', {
            'name': 'commentsCount',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('sharesCount', {
            'name': 'sharesCount',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('facebookPageId', {
            'name': 'facebookPageId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('facebookPage', {
            'name': 'facebookPage',
            'is_list': False,
            'optional': True,
            'type': 'models.FacebookPage',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_WhatsappNumber_relational_fields: Set[str] = {
        'user',
        'templates',
        'messages',
    }
_WhatsappNumber_fields: Dict['types.WhatsappNumberKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('phoneNumber', {
            'name': 'phoneNumber',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('displayName', {
            'name': 'displayName',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('businessAccountId', {
            'name': 'businessAccountId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('accessToken', {
            'name': 'accessToken',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('isActive', {
            'name': 'isActive',
            'is_list': False,
            'optional': False,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('userId', {
            'name': 'userId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('user', {
            'name': 'user',
            'is_list': False,
            'optional': True,
            'type': 'models.User',
            'is_relational': True,
            'documentation': None,
        }),
        ('templates', {
            'name': 'templates',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.WhatsappTemplate\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('messages', {
            'name': 'messages',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Message\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_WhatsappTemplate_relational_fields: Set[str] = {
        'whatsappNumber',
        'messages',
    }
_WhatsappTemplate_fields: Dict['types.WhatsappTemplateKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('name', {
            'name': 'name',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('language', {
            'name': 'language',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('status', {
            'name': 'status',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('category', {
            'name': 'category',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('components', {
            'name': 'components',
            'is_list': False,
            'optional': False,
            'type': 'fields.Json',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('whatsappNumberId', {
            'name': 'whatsappNumberId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('whatsappNumber', {
            'name': 'whatsappNumber',
            'is_list': False,
            'optional': True,
            'type': 'models.WhatsappNumber',
            'is_relational': True,
            'documentation': None,
        }),
        ('messages', {
            'name': 'messages',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Message\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_Lead_relational_fields: Set[str] = {
        'user',
        'facebookPage',
        'tags',
        'messages',
    }
_Lead_fields: Dict['types.LeadKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('firstName', {
            'name': 'firstName',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('lastName', {
            'name': 'lastName',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('email', {
            'name': 'email',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('phoneNumber', {
            'name': 'phoneNumber',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('facebookUserId', {
            'name': 'facebookUserId',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('source', {
            'name': 'source',
            'is_list': False,
            'optional': False,
            'type': 'enums.LeadSource',
            'is_relational': False,
            'documentation': None,
        }),
        ('status', {
            'name': 'status',
            'is_list': False,
            'optional': False,
            'type': 'enums.LeadStatus',
            'is_relational': False,
            'documentation': None,
        }),
        ('consentGiven', {
            'name': 'consentGiven',
            'is_list': False,
            'optional': False,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('consentTimestamp', {
            'name': 'consentTimestamp',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('consentType', {
            'name': 'consentType',
            'is_list': False,
            'optional': True,
            'type': 'enums.ConsentType',
            'is_relational': False,
            'documentation': None,
        }),
        ('lastInteraction', {
            'name': 'lastInteraction',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('userId', {
            'name': 'userId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('user', {
            'name': 'user',
            'is_list': False,
            'optional': True,
            'type': 'models.User',
            'is_relational': True,
            'documentation': None,
        }),
        ('facebookPageId', {
            'name': 'facebookPageId',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('facebookPage', {
            'name': 'facebookPage',
            'is_list': False,
            'optional': True,
            'type': 'models.FacebookPage',
            'is_relational': True,
            'documentation': None,
        }),
        ('tags', {
            'name': 'tags',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.LeadTag\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('messages', {
            'name': 'messages',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Message\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_Tag_relational_fields: Set[str] = {
        'leads',
    }
_Tag_fields: Dict['types.TagKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('name', {
            'name': 'name',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('color', {
            'name': 'color',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('leads', {
            'name': 'leads',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.LeadTag\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_LeadTag_relational_fields: Set[str] = {
        'lead',
        'tag',
    }
_LeadTag_fields: Dict['types.LeadTagKeys', PartialModelField] = OrderedDict(
    [
        ('leadId', {
            'name': 'leadId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('tagId', {
            'name': 'tagId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('lead', {
            'name': 'lead',
            'is_list': False,
            'optional': True,
            'type': 'models.Lead',
            'is_relational': True,
            'documentation': None,
        }),
        ('tag', {
            'name': 'tag',
            'is_list': False,
            'optional': True,
            'type': 'models.Tag',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_Message_relational_fields: Set[str] = {
        'lead',
        'campaign',
        'whatsappNumber',
        'whatsappTemplate',
    }
_Message_fields: Dict['types.MessageKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('type', {
            'name': 'type',
            'is_list': False,
            'optional': False,
            'type': 'enums.MessageType',
            'is_relational': False,
            'documentation': None,
        }),
        ('platform', {
            'name': 'platform',
            'is_list': False,
            'optional': False,
            'type': 'enums.MessagePlatform',
            'is_relational': False,
            'documentation': None,
        }),
        ('recipient', {
            'name': 'recipient',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('content', {
            'name': 'content',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('status', {
            'name': 'status',
            'is_list': False,
            'optional': False,
            'type': 'enums.MessageStatus',
            'is_relational': False,
            'documentation': None,
        }),
        ('sentAt', {
            'name': 'sentAt',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('deliveredAt', {
            'name': 'deliveredAt',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('readAt', {
            'name': 'readAt',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('errorMessage', {
            'name': 'errorMessage',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('retryCount', {
            'name': 'retryCount',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('leadId', {
            'name': 'leadId',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('lead', {
            'name': 'lead',
            'is_list': False,
            'optional': True,
            'type': 'models.Lead',
            'is_relational': True,
            'documentation': None,
        }),
        ('campaignId', {
            'name': 'campaignId',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('campaign', {
            'name': 'campaign',
            'is_list': False,
            'optional': True,
            'type': 'models.Campaign',
            'is_relational': True,
            'documentation': None,
        }),
        ('whatsappNumberId', {
            'name': 'whatsappNumberId',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('whatsappNumber', {
            'name': 'whatsappNumber',
            'is_list': False,
            'optional': True,
            'type': 'models.WhatsappNumber',
            'is_relational': True,
            'documentation': None,
        }),
        ('whatsappTemplateId', {
            'name': 'whatsappTemplateId',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('whatsappTemplate', {
            'name': 'whatsappTemplate',
            'is_list': False,
            'optional': True,
            'type': 'models.WhatsappTemplate',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_Campaign_relational_fields: Set[str] = {
        'user',
        'messages',
    }
_Campaign_fields: Dict['types.CampaignKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('name', {
            'name': 'name',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('description', {
            'name': 'description',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('type', {
            'name': 'type',
            'is_list': False,
            'optional': False,
            'type': 'enums.CampaignType',
            'is_relational': False,
            'documentation': None,
        }),
        ('status', {
            'name': 'status',
            'is_list': False,
            'optional': False,
            'type': 'enums.CampaignStatus',
            'is_relational': False,
            'documentation': None,
        }),
        ('scheduledAt', {
            'name': 'scheduledAt',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('startedAt', {
            'name': 'startedAt',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('completedAt', {
            'name': 'completedAt',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('targetAudience', {
            'name': 'targetAudience',
            'is_list': False,
            'optional': False,
            'type': 'fields.Json',
            'is_relational': False,
            'documentation': None,
        }),
        ('messageTemplate', {
            'name': 'messageTemplate',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('userId', {
            'name': 'userId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('user', {
            'name': 'user',
            'is_list': False,
            'optional': True,
            'type': 'models.User',
            'is_relational': True,
            'documentation': None,
        }),
        ('messages', {
            'name': 'messages',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Message\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_AuditLog_relational_fields: Set[str] = {
        'user',
    }
_AuditLog_fields: Dict['types.AuditLogKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('action', {
            'name': 'action',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('resource', {
            'name': 'resource',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('resourceId', {
            'name': 'resourceId',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('details', {
            'name': 'details',
            'is_list': False,
            'optional': True,
            'type': 'fields.Json',
            'is_relational': False,
            'documentation': None,
        }),
        ('ipAddress', {
            'name': 'ipAddress',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('userAgent', {
            'name': 'userAgent',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('userId', {
            'name': 'userId',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('user', {
            'name': 'user',
            'is_list': False,
            'optional': True,
            'type': 'models.User',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_ApiKey_relational_fields: Set[str] = set()  # pyright: ignore[reportUnusedVariable]
_ApiKey_fields: Dict['types.ApiKeyKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('name', {
            'name': 'name',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('keyHash', {
            'name': 'keyHash',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('permissions', {
            'name': 'permissions',
            'is_list': False,
            'optional': False,
            'type': 'fields.Json',
            'is_relational': False,
            'documentation': None,
        }),
        ('isActive', {
            'name': 'isActive',
            'is_list': False,
            'optional': False,
            'type': '_bool',
            'is_relational': False,
            'documentation': None,
        }),
        ('lastUsedAt', {
            'name': 'lastUsedAt',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('expiresAt', {
            'name': 'expiresAt',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)

_RateLimit_relational_fields: Set[str] = set()  # pyright: ignore[reportUnusedVariable]
_RateLimit_fields: Dict['types.RateLimitKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('identifier', {
            'name': 'identifier',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('endpoint', {
            'name': 'endpoint',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('requestCount', {
            'name': 'requestCount',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('windowStart', {
            'name': 'windowStart',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)



# we have to import ourselves as relation types are namespaced to models
# e.g. models.Post
from . import models, actions

# required to support relationships between models
model_rebuild(User)
model_rebuild(FacebookPage)
model_rebuild(FacebookPost)
model_rebuild(WhatsappNumber)
model_rebuild(WhatsappTemplate)
model_rebuild(Lead)
model_rebuild(Tag)
model_rebuild(LeadTag)
model_rebuild(Message)
model_rebuild(Campaign)
model_rebuild(AuditLog)
model_rebuild(ApiKey)
model_rebuild(RateLimit)
