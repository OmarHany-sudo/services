# -*- coding: utf-8 -*-
# code generated by Prisma. DO NOT EDIT.
# pyright: reportUnusedImport=false
# fmt: off
from __future__ import annotations

# global imports for type checking
from builtins import bool as _bool
from builtins import int as _int
from builtins import float as _float
from builtins import str as _str
import sys
import decimal
import datetime
from typing import (
    TYPE_CHECKING,
    Optional,
    Iterable,
    Iterator,
    Sequence,
    Callable,
    ClassVar,
    NoReturn,
    TypeVar,
    Generic,
    Mapping,
    Tuple,
    Union,
    List,
    Dict,
    Type,
    Any,
    Set,
    overload,
    cast,
)
from typing_extensions import TypedDict, Literal


LiteralString = str
# -- template actions.py.jinja --
from typing import TypeVar
import warnings

from . import types, errors, bases
from ._compat import model_parse
from ._constants import CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED

if TYPE_CHECKING:
    from .client import Prisma
    from .bases import _PrismaModel


_PrismaModelT = TypeVar('_PrismaModelT', bound='_PrismaModel')


class UserActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.User]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await User.prisma().query_raw(
            'SELECT * FROM User WHERE id = $1',
            'bbadfchfja',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.User
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await User.prisma().query_first(
            'SELECT * FROM User WHERE email = $1',
            'dhheabfhf',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.UserCreateInput,
        include: Optional[types.UserInclude] = None
    ) -> _PrismaModelT:
        """Create a new User record.

        Parameters
        ----------
        data
            User record data
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The created User record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a User record from just the required fields
        user = await User.prisma().create(
            data={
                # data to create a User record
                'email': 'ggciceaie',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.UserCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple User records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of User record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await User.prisma().create_many(
            data=[
                {
                    # data to create a User record
                    'email': 'bbehjachib',
                },
                {
                    # data to create a User record
                    'email': 'cadfabfehe',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.UserWhereUniqueInput,
        include: Optional[types.UserInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single User record.

        Parameters
        ----------
        where
            User filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The deleted User record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        user = await User.prisma().delete(
            where={
                'id': 'dgiiaaijj',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.UserWhereUniqueInput,
        include: Optional[types.UserInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique User record.

        Parameters
        ----------
        where
            User filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The found User record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        user = await User.prisma().find_unique(
            where={
                'id': 'bfaiacjjfc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.UserWhereUniqueInput,
        include: Optional[types.UserInclude] = None
    ) -> _PrismaModelT:
        """Find a unique User record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            User filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The found User record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        user = await User.prisma().find_unique_or_raise(
            where={
                'id': 'eigcfgbif',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
        include: Optional[types.UserInclude] = None,
        order: Optional[Union[types.UserOrderByInput, List[types.UserOrderByInput]]] = None,
        distinct: Optional[List[types.UserScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple User records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of User records returned
        skip
            Ignore the first N results
        where
            User filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned User model
        order
            Order the returned User records by any field
        distinct
            Filter User records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.User]
            The list of all User records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 User records
        users = await User.prisma().find_many(take=10)

        # find the first 5 User records ordered by the name field
        users = await User.prisma().find_many(
            take=5,
            order={
                'name': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
        include: Optional[types.UserInclude] = None,
        order: Optional[Union[types.UserOrderByInput, List[types.UserOrderByInput]]] = None,
        distinct: Optional[List[types.UserScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single User record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            User filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned User model
        order
            Order the returned User records by any field
        distinct
            Filter User records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.User
            The first User record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second User record ordered by the image field
        user = await User.prisma().find_first(
            skip=1,
            order={
                'image': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
        include: Optional[types.UserInclude] = None,
        order: Optional[Union[types.UserOrderByInput, List[types.UserOrderByInput]]] = None,
        distinct: Optional[List[types.UserScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single User record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            User filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned User model
        order
            Order the returned User records by any field
        distinct
            Filter User records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.User
            The first User record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second User record ordered by the role field
        user = await User.prisma().find_first_or_raise(
            skip=1,
            order={
                'role': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.UserUpdateInput,
        where: types.UserWhereUniqueInput,
        include: Optional[types.UserInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single User record.

        Parameters
        ----------
        data
            User record data specifying what to update
        where
            User filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The updated User record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await User.prisma().update(
            where={
                'id': 'bagcfbhiig',
            },
            data={
                # data to update the User record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.UserWhereUniqueInput,
        data: types.UserUpsertInput,
        include: Optional[types.UserInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            User filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The created or updated User record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        user = await User.prisma().upsert(
            where={
                'id': 'cghideieh',
            },
            data={
                'create': {
                    'id': 'cghideieh',
                    'email': 'cadfabfehe',
                },
                'update': {
                    'email': 'cadfabfehe',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.UserUpdateManyMutationInput,
        where: types.UserWhereInput,
    ) -> int:
        """Update multiple User records

        Parameters
        ----------
        data
            User data to update the selected User records to
        where
            Filter to select the User records to update

        Returns
        -------
        int
            The total number of User records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all User records
        total = await User.prisma().update_many(
            data={
                'createdAt': datetime.datetime.utcnow()
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
    ) -> int:
        """Count the number of User records present in the database

        Parameters
        ----------
        select
            Select the User fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            User filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.UserCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await User.prisma().count()

        # results: prisma.types.UserCountAggregateOutput
        results = await User.prisma().count(
            select={
                '_all': True,
                'updatedAt': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.UserCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
    ) -> types.UserCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.UserCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
    ) -> Union[int, types.UserCountAggregateOutput]:
        """Count the number of User records present in the database

        Parameters
        ----------
        select
            Select the User fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            User filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.UserCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await User.prisma().count()

        # results: prisma.types.UserCountAggregateOutput
        results = await User.prisma().count(
            select={
                '_all': True,
                'facebookId': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.UserCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.UserWhereInput] = None
    ) -> int:
        """Delete multiple User records.

        Parameters
        ----------
        where
            Optional User filter to find the records to be deleted

        Returns
        -------
        int
            The total number of User records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all User records
        total = await User.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.UserScalarFieldKeys'],
        *,
        where: Optional['types.UserWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.UserAvgAggregateInput'] = None,
        sum: Optional['types.UserSumAggregateInput'] = None,
        min: Optional['types.UserMinAggregateInput'] = None,
        max: Optional['types.UserMaxAggregateInput'] = None,
        having: Optional['types.UserScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.UserCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.UserScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.UserScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.UserGroupByOutput']:
        """Group User records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar User fields to group records by
        where
            User filter to select records
        take
            Limit the maximum number of User records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.UserGroupByOutput]
            A list of dictionaries representing the User record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group User records by facebookToken values
        # and count how many records are in each group
        results = await User.prisma().group_by(
            ['facebookToken'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class FacebookPageActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.FacebookPage]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await FacebookPage.prisma().query_raw(
            'SELECT * FROM FacebookPage WHERE id = $1',
            'biabhbdai',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.FacebookPage
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await FacebookPage.prisma().query_first(
            'SELECT * FROM FacebookPage WHERE facebookPageId = $1',
            'idghgaicb',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.FacebookPageCreateInput,
        include: Optional[types.FacebookPageInclude] = None
    ) -> _PrismaModelT:
        """Create a new FacebookPage record.

        Parameters
        ----------
        data
            FacebookPage record data
        include
            Specifies which relations should be loaded on the returned FacebookPage model

        Returns
        -------
        prisma.models.FacebookPage
            The created FacebookPage record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a FacebookPage record from just the required fields
        facebookpage = await FacebookPage.prisma().create(
            data={
                # data to create a FacebookPage record
                'facebookPageId': 'fjfddhigg',
                'name': 'hjaecfifb',
                'accessToken': 'cbbbjbfcii',
                'userId': 'bbejhfidcb',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.FacebookPageCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple FacebookPage records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of FacebookPage record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await FacebookPage.prisma().create_many(
            data=[
                {
                    # data to create a FacebookPage record
                    'facebookPageId': 'bgeecijdgg',
                    'name': 'bdiicjafbj',
                    'accessToken': 'bgehebiafc',
                    'userId': 'bghffegacj',
                },
                {
                    # data to create a FacebookPage record
                    'facebookPageId': 'bhghchehcc',
                    'name': 'dcgchcbbf',
                    'accessToken': 'bdedcabahc',
                    'userId': 'ghfhiafcb',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.FacebookPageWhereUniqueInput,
        include: Optional[types.FacebookPageInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single FacebookPage record.

        Parameters
        ----------
        where
            FacebookPage filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned FacebookPage model

        Returns
        -------
        prisma.models.FacebookPage
            The deleted FacebookPage record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        facebookpage = await FacebookPage.prisma().delete(
            where={
                'id': 'heejgedji',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.FacebookPageWhereUniqueInput,
        include: Optional[types.FacebookPageInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique FacebookPage record.

        Parameters
        ----------
        where
            FacebookPage filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned FacebookPage model

        Returns
        -------
        prisma.models.FacebookPage
            The found FacebookPage record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        facebookpage = await FacebookPage.prisma().find_unique(
            where={
                'id': 'bjgjgibgbf',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.FacebookPageWhereUniqueInput,
        include: Optional[types.FacebookPageInclude] = None
    ) -> _PrismaModelT:
        """Find a unique FacebookPage record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            FacebookPage filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned FacebookPage model

        Returns
        -------
        prisma.models.FacebookPage
            The found FacebookPage record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        facebookpage = await FacebookPage.prisma().find_unique_or_raise(
            where={
                'id': 'bbbgbhfjge',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.FacebookPageWhereInput] = None,
        cursor: Optional[types.FacebookPageWhereUniqueInput] = None,
        include: Optional[types.FacebookPageInclude] = None,
        order: Optional[Union[types.FacebookPageOrderByInput, List[types.FacebookPageOrderByInput]]] = None,
        distinct: Optional[List[types.FacebookPageScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple FacebookPage records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of FacebookPage records returned
        skip
            Ignore the first N results
        where
            FacebookPage filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned FacebookPage model
        order
            Order the returned FacebookPage records by any field
        distinct
            Filter FacebookPage records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.FacebookPage]
            The list of all FacebookPage records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 FacebookPage records
        facebookpages = await FacebookPage.prisma().find_many(take=10)

        # find the first 5 FacebookPage records ordered by the name field
        facebookpages = await FacebookPage.prisma().find_many(
            take=5,
            order={
                'name': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.FacebookPageWhereInput] = None,
        cursor: Optional[types.FacebookPageWhereUniqueInput] = None,
        include: Optional[types.FacebookPageInclude] = None,
        order: Optional[Union[types.FacebookPageOrderByInput, List[types.FacebookPageOrderByInput]]] = None,
        distinct: Optional[List[types.FacebookPageScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single FacebookPage record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            FacebookPage filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned FacebookPage model
        order
            Order the returned FacebookPage records by any field
        distinct
            Filter FacebookPage records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.FacebookPage
            The first FacebookPage record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second FacebookPage record ordered by the accessToken field
        facebookpage = await FacebookPage.prisma().find_first(
            skip=1,
            order={
                'accessToken': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.FacebookPageWhereInput] = None,
        cursor: Optional[types.FacebookPageWhereUniqueInput] = None,
        include: Optional[types.FacebookPageInclude] = None,
        order: Optional[Union[types.FacebookPageOrderByInput, List[types.FacebookPageOrderByInput]]] = None,
        distinct: Optional[List[types.FacebookPageScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single FacebookPage record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            FacebookPage filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned FacebookPage model
        order
            Order the returned FacebookPage records by any field
        distinct
            Filter FacebookPage records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.FacebookPage
            The first FacebookPage record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second FacebookPage record ordered by the tokenExpiry field
        facebookpage = await FacebookPage.prisma().find_first_or_raise(
            skip=1,
            order={
                'tokenExpiry': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.FacebookPageUpdateInput,
        where: types.FacebookPageWhereUniqueInput,
        include: Optional[types.FacebookPageInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single FacebookPage record.

        Parameters
        ----------
        data
            FacebookPage record data specifying what to update
        where
            FacebookPage filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned FacebookPage model

        Returns
        -------
        prisma.models.FacebookPage
            The updated FacebookPage record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        facebookpage = await FacebookPage.prisma().update(
            where={
                'id': 'igbehcbab',
            },
            data={
                # data to update the FacebookPage record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.FacebookPageWhereUniqueInput,
        data: types.FacebookPageUpsertInput,
        include: Optional[types.FacebookPageInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            FacebookPage filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned FacebookPage model

        Returns
        -------
        prisma.models.FacebookPage
            The created or updated FacebookPage record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        facebookpage = await FacebookPage.prisma().upsert(
            where={
                'id': 'bdadaadhag',
            },
            data={
                'create': {
                    'id': 'bdadaadhag',
                    'facebookPageId': 'bhghchehcc',
                    'name': 'dcgchcbbf',
                    'accessToken': 'bdedcabahc',
                    'userId': 'ghfhiafcb',
                },
                'update': {
                    'facebookPageId': 'bhghchehcc',
                    'name': 'dcgchcbbf',
                    'accessToken': 'bdedcabahc',
                    'userId': 'ghfhiafcb',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.FacebookPageUpdateManyMutationInput,
        where: types.FacebookPageWhereInput,
    ) -> int:
        """Update multiple FacebookPage records

        Parameters
        ----------
        data
            FacebookPage data to update the selected FacebookPage records to
        where
            Filter to select the FacebookPage records to update

        Returns
        -------
        int
            The total number of FacebookPage records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all FacebookPage records
        total = await FacebookPage.prisma().update_many(
            data={
                'isActive': False
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.FacebookPageWhereInput] = None,
        cursor: Optional[types.FacebookPageWhereUniqueInput] = None,
    ) -> int:
        """Count the number of FacebookPage records present in the database

        Parameters
        ----------
        select
            Select the FacebookPage fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            FacebookPage filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.FacebookPageCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await FacebookPage.prisma().count()

        # results: prisma.types.FacebookPageCountAggregateOutput
        results = await FacebookPage.prisma().count(
            select={
                '_all': True,
                'createdAt': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.FacebookPageCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.FacebookPageWhereInput] = None,
        cursor: Optional[types.FacebookPageWhereUniqueInput] = None,
    ) -> types.FacebookPageCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.FacebookPageCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.FacebookPageWhereInput] = None,
        cursor: Optional[types.FacebookPageWhereUniqueInput] = None,
    ) -> Union[int, types.FacebookPageCountAggregateOutput]:
        """Count the number of FacebookPage records present in the database

        Parameters
        ----------
        select
            Select the FacebookPage fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            FacebookPage filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.FacebookPageCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await FacebookPage.prisma().count()

        # results: prisma.types.FacebookPageCountAggregateOutput
        results = await FacebookPage.prisma().count(
            select={
                '_all': True,
                'updatedAt': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.FacebookPageCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.FacebookPageWhereInput] = None
    ) -> int:
        """Delete multiple FacebookPage records.

        Parameters
        ----------
        where
            Optional FacebookPage filter to find the records to be deleted

        Returns
        -------
        int
            The total number of FacebookPage records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all FacebookPage records
        total = await FacebookPage.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.FacebookPageScalarFieldKeys'],
        *,
        where: Optional['types.FacebookPageWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.FacebookPageAvgAggregateInput'] = None,
        sum: Optional['types.FacebookPageSumAggregateInput'] = None,
        min: Optional['types.FacebookPageMinAggregateInput'] = None,
        max: Optional['types.FacebookPageMaxAggregateInput'] = None,
        having: Optional['types.FacebookPageScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.FacebookPageCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.FacebookPageScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.FacebookPageScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.FacebookPageGroupByOutput']:
        """Group FacebookPage records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar FacebookPage fields to group records by
        where
            FacebookPage filter to select records
        take
            Limit the maximum number of FacebookPage records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.FacebookPageGroupByOutput]
            A list of dictionaries representing the FacebookPage record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group FacebookPage records by userId values
        # and count how many records are in each group
        results = await FacebookPage.prisma().group_by(
            ['userId'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class FacebookPostActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.FacebookPost]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await FacebookPost.prisma().query_raw(
            'SELECT * FROM FacebookPost WHERE id = $1',
            'caaaedabfc',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.FacebookPost
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await FacebookPost.prisma().query_first(
            'SELECT * FROM FacebookPost WHERE facebookPostId = $1',
            'bigibebcib',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.FacebookPostCreateInput,
        include: Optional[types.FacebookPostInclude] = None
    ) -> _PrismaModelT:
        """Create a new FacebookPost record.

        Parameters
        ----------
        data
            FacebookPost record data
        include
            Specifies which relations should be loaded on the returned FacebookPost model

        Returns
        -------
        prisma.models.FacebookPost
            The created FacebookPost record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a FacebookPost record from just the required fields
        facebookpost = await FacebookPost.prisma().create(
            data={
                # data to create a FacebookPost record
                'facebookPostId': 'bigaiehgcc',
                'createdTime': datetime.datetime.utcnow(),
                'facebookPageId': 'beeifcbebf',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.FacebookPostCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple FacebookPost records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of FacebookPost record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await FacebookPost.prisma().create_many(
            data=[
                {
                    # data to create a FacebookPost record
                    'facebookPostId': 'bgcigfahea',
                    'createdTime': datetime.datetime.utcnow(),
                    'facebookPageId': 'bcejgaggif',
                },
                {
                    # data to create a FacebookPost record
                    'facebookPostId': 'idfjadbcc',
                    'createdTime': datetime.datetime.utcnow(),
                    'facebookPageId': 'hgdhbjhhj',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.FacebookPostWhereUniqueInput,
        include: Optional[types.FacebookPostInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single FacebookPost record.

        Parameters
        ----------
        where
            FacebookPost filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned FacebookPost model

        Returns
        -------
        prisma.models.FacebookPost
            The deleted FacebookPost record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        facebookpost = await FacebookPost.prisma().delete(
            where={
                'id': 'ecjjjfbae',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.FacebookPostWhereUniqueInput,
        include: Optional[types.FacebookPostInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique FacebookPost record.

        Parameters
        ----------
        where
            FacebookPost filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned FacebookPost model

        Returns
        -------
        prisma.models.FacebookPost
            The found FacebookPost record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        facebookpost = await FacebookPost.prisma().find_unique(
            where={
                'id': 'bhhfibbigf',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.FacebookPostWhereUniqueInput,
        include: Optional[types.FacebookPostInclude] = None
    ) -> _PrismaModelT:
        """Find a unique FacebookPost record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            FacebookPost filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned FacebookPost model

        Returns
        -------
        prisma.models.FacebookPost
            The found FacebookPost record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        facebookpost = await FacebookPost.prisma().find_unique_or_raise(
            where={
                'id': 'ijdbeffgg',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.FacebookPostWhereInput] = None,
        cursor: Optional[types.FacebookPostWhereUniqueInput] = None,
        include: Optional[types.FacebookPostInclude] = None,
        order: Optional[Union[types.FacebookPostOrderByInput, List[types.FacebookPostOrderByInput]]] = None,
        distinct: Optional[List[types.FacebookPostScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple FacebookPost records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of FacebookPost records returned
        skip
            Ignore the first N results
        where
            FacebookPost filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned FacebookPost model
        order
            Order the returned FacebookPost records by any field
        distinct
            Filter FacebookPost records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.FacebookPost]
            The list of all FacebookPost records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 FacebookPost records
        facebookposts = await FacebookPost.prisma().find_many(take=10)

        # find the first 5 FacebookPost records ordered by the message field
        facebookposts = await FacebookPost.prisma().find_many(
            take=5,
            order={
                'message': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.FacebookPostWhereInput] = None,
        cursor: Optional[types.FacebookPostWhereUniqueInput] = None,
        include: Optional[types.FacebookPostInclude] = None,
        order: Optional[Union[types.FacebookPostOrderByInput, List[types.FacebookPostOrderByInput]]] = None,
        distinct: Optional[List[types.FacebookPostScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single FacebookPost record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            FacebookPost filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned FacebookPost model
        order
            Order the returned FacebookPost records by any field
        distinct
            Filter FacebookPost records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.FacebookPost
            The first FacebookPost record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second FacebookPost record ordered by the story field
        facebookpost = await FacebookPost.prisma().find_first(
            skip=1,
            order={
                'story': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.FacebookPostWhereInput] = None,
        cursor: Optional[types.FacebookPostWhereUniqueInput] = None,
        include: Optional[types.FacebookPostInclude] = None,
        order: Optional[Union[types.FacebookPostOrderByInput, List[types.FacebookPostOrderByInput]]] = None,
        distinct: Optional[List[types.FacebookPostScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single FacebookPost record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            FacebookPost filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned FacebookPost model
        order
            Order the returned FacebookPost records by any field
        distinct
            Filter FacebookPost records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.FacebookPost
            The first FacebookPost record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second FacebookPost record ordered by the createdTime field
        facebookpost = await FacebookPost.prisma().find_first_or_raise(
            skip=1,
            order={
                'createdTime': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.FacebookPostUpdateInput,
        where: types.FacebookPostWhereUniqueInput,
        include: Optional[types.FacebookPostInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single FacebookPost record.

        Parameters
        ----------
        data
            FacebookPost record data specifying what to update
        where
            FacebookPost filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned FacebookPost model

        Returns
        -------
        prisma.models.FacebookPost
            The updated FacebookPost record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        facebookpost = await FacebookPost.prisma().update(
            where={
                'id': 'jjfeafhfj',
            },
            data={
                # data to update the FacebookPost record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.FacebookPostWhereUniqueInput,
        data: types.FacebookPostUpsertInput,
        include: Optional[types.FacebookPostInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            FacebookPost filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned FacebookPost model

        Returns
        -------
        prisma.models.FacebookPost
            The created or updated FacebookPost record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        facebookpost = await FacebookPost.prisma().upsert(
            where={
                'id': 'cbachdgfce',
            },
            data={
                'create': {
                    'id': 'cbachdgfce',
                    'facebookPostId': 'idfjadbcc',
                    'createdTime': datetime.datetime.utcnow(),
                    'facebookPageId': 'hgdhbjhhj',
                },
                'update': {
                    'facebookPostId': 'idfjadbcc',
                    'createdTime': datetime.datetime.utcnow(),
                    'facebookPageId': 'hgdhbjhhj',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.FacebookPostUpdateManyMutationInput,
        where: types.FacebookPostWhereInput,
    ) -> int:
        """Update multiple FacebookPost records

        Parameters
        ----------
        data
            FacebookPost data to update the selected FacebookPost records to
        where
            Filter to select the FacebookPost records to update

        Returns
        -------
        int
            The total number of FacebookPost records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all FacebookPost records
        total = await FacebookPost.prisma().update_many(
            data={
                'likesCount': 271520213
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.FacebookPostWhereInput] = None,
        cursor: Optional[types.FacebookPostWhereUniqueInput] = None,
    ) -> int:
        """Count the number of FacebookPost records present in the database

        Parameters
        ----------
        select
            Select the FacebookPost fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            FacebookPost filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.FacebookPostCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await FacebookPost.prisma().count()

        # results: prisma.types.FacebookPostCountAggregateOutput
        results = await FacebookPost.prisma().count(
            select={
                '_all': True,
                'commentsCount': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.FacebookPostCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.FacebookPostWhereInput] = None,
        cursor: Optional[types.FacebookPostWhereUniqueInput] = None,
    ) -> types.FacebookPostCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.FacebookPostCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.FacebookPostWhereInput] = None,
        cursor: Optional[types.FacebookPostWhereUniqueInput] = None,
    ) -> Union[int, types.FacebookPostCountAggregateOutput]:
        """Count the number of FacebookPost records present in the database

        Parameters
        ----------
        select
            Select the FacebookPost fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            FacebookPost filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.FacebookPostCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await FacebookPost.prisma().count()

        # results: prisma.types.FacebookPostCountAggregateOutput
        results = await FacebookPost.prisma().count(
            select={
                '_all': True,
                'sharesCount': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.FacebookPostCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.FacebookPostWhereInput] = None
    ) -> int:
        """Delete multiple FacebookPost records.

        Parameters
        ----------
        where
            Optional FacebookPost filter to find the records to be deleted

        Returns
        -------
        int
            The total number of FacebookPost records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all FacebookPost records
        total = await FacebookPost.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.FacebookPostScalarFieldKeys'],
        *,
        where: Optional['types.FacebookPostWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.FacebookPostAvgAggregateInput'] = None,
        sum: Optional['types.FacebookPostSumAggregateInput'] = None,
        min: Optional['types.FacebookPostMinAggregateInput'] = None,
        max: Optional['types.FacebookPostMaxAggregateInput'] = None,
        having: Optional['types.FacebookPostScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.FacebookPostCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.FacebookPostScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.FacebookPostScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.FacebookPostGroupByOutput']:
        """Group FacebookPost records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar FacebookPost fields to group records by
        where
            FacebookPost filter to select records
        take
            Limit the maximum number of FacebookPost records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.FacebookPostGroupByOutput]
            A list of dictionaries representing the FacebookPost record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group FacebookPost records by createdAt values
        # and count how many records are in each group
        results = await FacebookPost.prisma().group_by(
            ['createdAt'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class WhatsappNumberActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.WhatsappNumber]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await WhatsappNumber.prisma().query_raw(
            'SELECT * FROM WhatsappNumber WHERE id = $1',
            'efggddide',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.WhatsappNumber
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await WhatsappNumber.prisma().query_first(
            'SELECT * FROM WhatsappNumber WHERE phoneNumber = $1',
            'caficfigfb',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.WhatsappNumberCreateInput,
        include: Optional[types.WhatsappNumberInclude] = None
    ) -> _PrismaModelT:
        """Create a new WhatsappNumber record.

        Parameters
        ----------
        data
            WhatsappNumber record data
        include
            Specifies which relations should be loaded on the returned WhatsappNumber model

        Returns
        -------
        prisma.models.WhatsappNumber
            The created WhatsappNumber record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a WhatsappNumber record from just the required fields
        whatsappnumber = await WhatsappNumber.prisma().create(
            data={
                # data to create a WhatsappNumber record
                'phoneNumber': 'bfidgijfjc',
                'businessAccountId': 'ihieecagf',
                'accessToken': 'bghfciaafe',
                'userId': 'bgchfhgceh',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.WhatsappNumberCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple WhatsappNumber records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of WhatsappNumber record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await WhatsappNumber.prisma().create_many(
            data=[
                {
                    # data to create a WhatsappNumber record
                    'phoneNumber': 'cafeiaccbc',
                    'businessAccountId': 'gaddfhfh',
                    'accessToken': 'gieegcbeg',
                    'userId': 'bgcffadich',
                },
                {
                    # data to create a WhatsappNumber record
                    'phoneNumber': 'fcbichhci',
                    'businessAccountId': 'bcggadccgf',
                    'accessToken': 'jdcfdcgc',
                    'userId': 'cafdaehjid',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.WhatsappNumberWhereUniqueInput,
        include: Optional[types.WhatsappNumberInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single WhatsappNumber record.

        Parameters
        ----------
        where
            WhatsappNumber filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned WhatsappNumber model

        Returns
        -------
        prisma.models.WhatsappNumber
            The deleted WhatsappNumber record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        whatsappnumber = await WhatsappNumber.prisma().delete(
            where={
                'id': 'gifdddbia',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.WhatsappNumberWhereUniqueInput,
        include: Optional[types.WhatsappNumberInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique WhatsappNumber record.

        Parameters
        ----------
        where
            WhatsappNumber filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned WhatsappNumber model

        Returns
        -------
        prisma.models.WhatsappNumber
            The found WhatsappNumber record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        whatsappnumber = await WhatsappNumber.prisma().find_unique(
            where={
                'id': 'bchehecef',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.WhatsappNumberWhereUniqueInput,
        include: Optional[types.WhatsappNumberInclude] = None
    ) -> _PrismaModelT:
        """Find a unique WhatsappNumber record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            WhatsappNumber filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned WhatsappNumber model

        Returns
        -------
        prisma.models.WhatsappNumber
            The found WhatsappNumber record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        whatsappnumber = await WhatsappNumber.prisma().find_unique_or_raise(
            where={
                'id': 'jeijcbhfe',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.WhatsappNumberWhereInput] = None,
        cursor: Optional[types.WhatsappNumberWhereUniqueInput] = None,
        include: Optional[types.WhatsappNumberInclude] = None,
        order: Optional[Union[types.WhatsappNumberOrderByInput, List[types.WhatsappNumberOrderByInput]]] = None,
        distinct: Optional[List[types.WhatsappNumberScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple WhatsappNumber records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of WhatsappNumber records returned
        skip
            Ignore the first N results
        where
            WhatsappNumber filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned WhatsappNumber model
        order
            Order the returned WhatsappNumber records by any field
        distinct
            Filter WhatsappNumber records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.WhatsappNumber]
            The list of all WhatsappNumber records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 WhatsappNumber records
        whatsappnumbers = await WhatsappNumber.prisma().find_many(take=10)

        # find the first 5 WhatsappNumber records ordered by the displayName field
        whatsappnumbers = await WhatsappNumber.prisma().find_many(
            take=5,
            order={
                'displayName': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.WhatsappNumberWhereInput] = None,
        cursor: Optional[types.WhatsappNumberWhereUniqueInput] = None,
        include: Optional[types.WhatsappNumberInclude] = None,
        order: Optional[Union[types.WhatsappNumberOrderByInput, List[types.WhatsappNumberOrderByInput]]] = None,
        distinct: Optional[List[types.WhatsappNumberScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single WhatsappNumber record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            WhatsappNumber filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned WhatsappNumber model
        order
            Order the returned WhatsappNumber records by any field
        distinct
            Filter WhatsappNumber records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.WhatsappNumber
            The first WhatsappNumber record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second WhatsappNumber record ordered by the businessAccountId field
        whatsappnumber = await WhatsappNumber.prisma().find_first(
            skip=1,
            order={
                'businessAccountId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.WhatsappNumberWhereInput] = None,
        cursor: Optional[types.WhatsappNumberWhereUniqueInput] = None,
        include: Optional[types.WhatsappNumberInclude] = None,
        order: Optional[Union[types.WhatsappNumberOrderByInput, List[types.WhatsappNumberOrderByInput]]] = None,
        distinct: Optional[List[types.WhatsappNumberScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single WhatsappNumber record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            WhatsappNumber filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned WhatsappNumber model
        order
            Order the returned WhatsappNumber records by any field
        distinct
            Filter WhatsappNumber records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.WhatsappNumber
            The first WhatsappNumber record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second WhatsappNumber record ordered by the accessToken field
        whatsappnumber = await WhatsappNumber.prisma().find_first_or_raise(
            skip=1,
            order={
                'accessToken': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.WhatsappNumberUpdateInput,
        where: types.WhatsappNumberWhereUniqueInput,
        include: Optional[types.WhatsappNumberInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single WhatsappNumber record.

        Parameters
        ----------
        data
            WhatsappNumber record data specifying what to update
        where
            WhatsappNumber filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned WhatsappNumber model

        Returns
        -------
        prisma.models.WhatsappNumber
            The updated WhatsappNumber record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        whatsappnumber = await WhatsappNumber.prisma().update(
            where={
                'id': 'bjgejjabff',
            },
            data={
                # data to update the WhatsappNumber record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.WhatsappNumberWhereUniqueInput,
        data: types.WhatsappNumberUpsertInput,
        include: Optional[types.WhatsappNumberInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            WhatsappNumber filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned WhatsappNumber model

        Returns
        -------
        prisma.models.WhatsappNumber
            The created or updated WhatsappNumber record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        whatsappnumber = await WhatsappNumber.prisma().upsert(
            where={
                'id': 'bcciijbibg',
            },
            data={
                'create': {
                    'id': 'bcciijbibg',
                    'phoneNumber': 'fcbichhci',
                    'businessAccountId': 'bcggadccgf',
                    'accessToken': 'jdcfdcgc',
                    'userId': 'cafdaehjid',
                },
                'update': {
                    'phoneNumber': 'fcbichhci',
                    'businessAccountId': 'bcggadccgf',
                    'accessToken': 'jdcfdcgc',
                    'userId': 'cafdaehjid',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.WhatsappNumberUpdateManyMutationInput,
        where: types.WhatsappNumberWhereInput,
    ) -> int:
        """Update multiple WhatsappNumber records

        Parameters
        ----------
        data
            WhatsappNumber data to update the selected WhatsappNumber records to
        where
            Filter to select the WhatsappNumber records to update

        Returns
        -------
        int
            The total number of WhatsappNumber records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all WhatsappNumber records
        total = await WhatsappNumber.prisma().update_many(
            data={
                'isActive': False
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.WhatsappNumberWhereInput] = None,
        cursor: Optional[types.WhatsappNumberWhereUniqueInput] = None,
    ) -> int:
        """Count the number of WhatsappNumber records present in the database

        Parameters
        ----------
        select
            Select the WhatsappNumber fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            WhatsappNumber filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.WhatsappNumberCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await WhatsappNumber.prisma().count()

        # results: prisma.types.WhatsappNumberCountAggregateOutput
        results = await WhatsappNumber.prisma().count(
            select={
                '_all': True,
                'createdAt': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.WhatsappNumberCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.WhatsappNumberWhereInput] = None,
        cursor: Optional[types.WhatsappNumberWhereUniqueInput] = None,
    ) -> types.WhatsappNumberCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.WhatsappNumberCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.WhatsappNumberWhereInput] = None,
        cursor: Optional[types.WhatsappNumberWhereUniqueInput] = None,
    ) -> Union[int, types.WhatsappNumberCountAggregateOutput]:
        """Count the number of WhatsappNumber records present in the database

        Parameters
        ----------
        select
            Select the WhatsappNumber fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            WhatsappNumber filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.WhatsappNumberCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await WhatsappNumber.prisma().count()

        # results: prisma.types.WhatsappNumberCountAggregateOutput
        results = await WhatsappNumber.prisma().count(
            select={
                '_all': True,
                'updatedAt': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.WhatsappNumberCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.WhatsappNumberWhereInput] = None
    ) -> int:
        """Delete multiple WhatsappNumber records.

        Parameters
        ----------
        where
            Optional WhatsappNumber filter to find the records to be deleted

        Returns
        -------
        int
            The total number of WhatsappNumber records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all WhatsappNumber records
        total = await WhatsappNumber.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.WhatsappNumberScalarFieldKeys'],
        *,
        where: Optional['types.WhatsappNumberWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.WhatsappNumberAvgAggregateInput'] = None,
        sum: Optional['types.WhatsappNumberSumAggregateInput'] = None,
        min: Optional['types.WhatsappNumberMinAggregateInput'] = None,
        max: Optional['types.WhatsappNumberMaxAggregateInput'] = None,
        having: Optional['types.WhatsappNumberScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.WhatsappNumberCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.WhatsappNumberScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.WhatsappNumberScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.WhatsappNumberGroupByOutput']:
        """Group WhatsappNumber records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar WhatsappNumber fields to group records by
        where
            WhatsappNumber filter to select records
        take
            Limit the maximum number of WhatsappNumber records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.WhatsappNumberGroupByOutput]
            A list of dictionaries representing the WhatsappNumber record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group WhatsappNumber records by userId values
        # and count how many records are in each group
        results = await WhatsappNumber.prisma().group_by(
            ['userId'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class WhatsappTemplateActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.WhatsappTemplate]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await WhatsappTemplate.prisma().query_raw(
            'SELECT * FROM WhatsappTemplate WHERE id = $1',
            'bccdfhdigc',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.WhatsappTemplate
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await WhatsappTemplate.prisma().query_first(
            'SELECT * FROM WhatsappTemplate WHERE name = $1',
            'febcgjbfj',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.WhatsappTemplateCreateInput,
        include: Optional[types.WhatsappTemplateInclude] = None
    ) -> _PrismaModelT:
        """Create a new WhatsappTemplate record.

        Parameters
        ----------
        data
            WhatsappTemplate record data
        include
            Specifies which relations should be loaded on the returned WhatsappTemplate model

        Returns
        -------
        prisma.models.WhatsappTemplate
            The created WhatsappTemplate record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a WhatsappTemplate record from just the required fields
        whatsapptemplate = await WhatsappTemplate.prisma().create(
            data={
                # data to create a WhatsappTemplate record
                'name': 'bageiegghg',
                'language': 'faidicegb',
                'status': 'bacecgfhbe',
                'category': 'ihcahiead',
                'components': Json({'biheheiajg': True}),
                'whatsappNumberId': 'jbgijghgb',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.WhatsappTemplateCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple WhatsappTemplate records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of WhatsappTemplate record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await WhatsappTemplate.prisma().create_many(
            data=[
                {
                    # data to create a WhatsappTemplate record
                    'name': 'hgjcghfbi',
                    'language': 'icadbcehj',
                    'status': 'jchciaee',
                    'category': 'deeificjd',
                    'components': Json({'bbcbhebbda': True}),
                    'whatsappNumberId': 'bejfijgcfb',
                },
                {
                    # data to create a WhatsappTemplate record
                    'name': 'caifcbgii',
                    'language': 'igaibbfgj',
                    'status': 'bggajdcbbi',
                    'category': 'fcfhgbjed',
                    'components': Json({'hdgcajhjg': True}),
                    'whatsappNumberId': 'ejdjahicb',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.WhatsappTemplateWhereUniqueInput,
        include: Optional[types.WhatsappTemplateInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single WhatsappTemplate record.

        Parameters
        ----------
        where
            WhatsappTemplate filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned WhatsappTemplate model

        Returns
        -------
        prisma.models.WhatsappTemplate
            The deleted WhatsappTemplate record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        whatsapptemplate = await WhatsappTemplate.prisma().delete(
            where={
                'id': 'gdjgigfgc',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.WhatsappTemplateWhereUniqueInput,
        include: Optional[types.WhatsappTemplateInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique WhatsappTemplate record.

        Parameters
        ----------
        where
            WhatsappTemplate filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned WhatsappTemplate model

        Returns
        -------
        prisma.models.WhatsappTemplate
            The found WhatsappTemplate record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        whatsapptemplate = await WhatsappTemplate.prisma().find_unique(
            where={
                'id': 'gfeaahdeh',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.WhatsappTemplateWhereUniqueInput,
        include: Optional[types.WhatsappTemplateInclude] = None
    ) -> _PrismaModelT:
        """Find a unique WhatsappTemplate record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            WhatsappTemplate filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned WhatsappTemplate model

        Returns
        -------
        prisma.models.WhatsappTemplate
            The found WhatsappTemplate record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        whatsapptemplate = await WhatsappTemplate.prisma().find_unique_or_raise(
            where={
                'id': 'bjafcgbffc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.WhatsappTemplateWhereInput] = None,
        cursor: Optional[types.WhatsappTemplateWhereUniqueInput] = None,
        include: Optional[types.WhatsappTemplateInclude] = None,
        order: Optional[Union[types.WhatsappTemplateOrderByInput, List[types.WhatsappTemplateOrderByInput]]] = None,
        distinct: Optional[List[types.WhatsappTemplateScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple WhatsappTemplate records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of WhatsappTemplate records returned
        skip
            Ignore the first N results
        where
            WhatsappTemplate filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned WhatsappTemplate model
        order
            Order the returned WhatsappTemplate records by any field
        distinct
            Filter WhatsappTemplate records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.WhatsappTemplate]
            The list of all WhatsappTemplate records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 WhatsappTemplate records
        whatsapptemplates = await WhatsappTemplate.prisma().find_many(take=10)

        # find the first 5 WhatsappTemplate records ordered by the language field
        whatsapptemplates = await WhatsappTemplate.prisma().find_many(
            take=5,
            order={
                'language': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.WhatsappTemplateWhereInput] = None,
        cursor: Optional[types.WhatsappTemplateWhereUniqueInput] = None,
        include: Optional[types.WhatsappTemplateInclude] = None,
        order: Optional[Union[types.WhatsappTemplateOrderByInput, List[types.WhatsappTemplateOrderByInput]]] = None,
        distinct: Optional[List[types.WhatsappTemplateScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single WhatsappTemplate record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            WhatsappTemplate filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned WhatsappTemplate model
        order
            Order the returned WhatsappTemplate records by any field
        distinct
            Filter WhatsappTemplate records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.WhatsappTemplate
            The first WhatsappTemplate record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second WhatsappTemplate record ordered by the status field
        whatsapptemplate = await WhatsappTemplate.prisma().find_first(
            skip=1,
            order={
                'status': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.WhatsappTemplateWhereInput] = None,
        cursor: Optional[types.WhatsappTemplateWhereUniqueInput] = None,
        include: Optional[types.WhatsappTemplateInclude] = None,
        order: Optional[Union[types.WhatsappTemplateOrderByInput, List[types.WhatsappTemplateOrderByInput]]] = None,
        distinct: Optional[List[types.WhatsappTemplateScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single WhatsappTemplate record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            WhatsappTemplate filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned WhatsappTemplate model
        order
            Order the returned WhatsappTemplate records by any field
        distinct
            Filter WhatsappTemplate records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.WhatsappTemplate
            The first WhatsappTemplate record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second WhatsappTemplate record ordered by the category field
        whatsapptemplate = await WhatsappTemplate.prisma().find_first_or_raise(
            skip=1,
            order={
                'category': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.WhatsappTemplateUpdateInput,
        where: types.WhatsappTemplateWhereUniqueInput,
        include: Optional[types.WhatsappTemplateInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single WhatsappTemplate record.

        Parameters
        ----------
        data
            WhatsappTemplate record data specifying what to update
        where
            WhatsappTemplate filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned WhatsappTemplate model

        Returns
        -------
        prisma.models.WhatsappTemplate
            The updated WhatsappTemplate record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        whatsapptemplate = await WhatsappTemplate.prisma().update(
            where={
                'id': 'hihegjif',
            },
            data={
                # data to update the WhatsappTemplate record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.WhatsappTemplateWhereUniqueInput,
        data: types.WhatsappTemplateUpsertInput,
        include: Optional[types.WhatsappTemplateInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            WhatsappTemplate filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned WhatsappTemplate model

        Returns
        -------
        prisma.models.WhatsappTemplate
            The created or updated WhatsappTemplate record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        whatsapptemplate = await WhatsappTemplate.prisma().upsert(
            where={
                'id': 'bdjidcidac',
            },
            data={
                'create': {
                    'id': 'bdjidcidac',
                    'name': 'caifcbgii',
                    'language': 'igaibbfgj',
                    'status': 'bggajdcbbi',
                    'category': 'fcfhgbjed',
                    'components': Json({'hdgcajhjg': True}),
                    'whatsappNumberId': 'ejdjahicb',
                },
                'update': {
                    'name': 'caifcbgii',
                    'language': 'igaibbfgj',
                    'status': 'bggajdcbbi',
                    'category': 'fcfhgbjed',
                    'components': Json({'hdgcajhjg': True}),
                    'whatsappNumberId': 'ejdjahicb',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.WhatsappTemplateUpdateManyMutationInput,
        where: types.WhatsappTemplateWhereInput,
    ) -> int:
        """Update multiple WhatsappTemplate records

        Parameters
        ----------
        data
            WhatsappTemplate data to update the selected WhatsappTemplate records to
        where
            Filter to select the WhatsappTemplate records to update

        Returns
        -------
        int
            The total number of WhatsappTemplate records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all WhatsappTemplate records
        total = await WhatsappTemplate.prisma().update_many(
            data={
                'components': Json({'ifgaaagff': True})
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.WhatsappTemplateWhereInput] = None,
        cursor: Optional[types.WhatsappTemplateWhereUniqueInput] = None,
    ) -> int:
        """Count the number of WhatsappTemplate records present in the database

        Parameters
        ----------
        select
            Select the WhatsappTemplate fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            WhatsappTemplate filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.WhatsappTemplateCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await WhatsappTemplate.prisma().count()

        # results: prisma.types.WhatsappTemplateCountAggregateOutput
        results = await WhatsappTemplate.prisma().count(
            select={
                '_all': True,
                'createdAt': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.WhatsappTemplateCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.WhatsappTemplateWhereInput] = None,
        cursor: Optional[types.WhatsappTemplateWhereUniqueInput] = None,
    ) -> types.WhatsappTemplateCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.WhatsappTemplateCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.WhatsappTemplateWhereInput] = None,
        cursor: Optional[types.WhatsappTemplateWhereUniqueInput] = None,
    ) -> Union[int, types.WhatsappTemplateCountAggregateOutput]:
        """Count the number of WhatsappTemplate records present in the database

        Parameters
        ----------
        select
            Select the WhatsappTemplate fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            WhatsappTemplate filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.WhatsappTemplateCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await WhatsappTemplate.prisma().count()

        # results: prisma.types.WhatsappTemplateCountAggregateOutput
        results = await WhatsappTemplate.prisma().count(
            select={
                '_all': True,
                'updatedAt': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.WhatsappTemplateCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.WhatsappTemplateWhereInput] = None
    ) -> int:
        """Delete multiple WhatsappTemplate records.

        Parameters
        ----------
        where
            Optional WhatsappTemplate filter to find the records to be deleted

        Returns
        -------
        int
            The total number of WhatsappTemplate records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all WhatsappTemplate records
        total = await WhatsappTemplate.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.WhatsappTemplateScalarFieldKeys'],
        *,
        where: Optional['types.WhatsappTemplateWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.WhatsappTemplateAvgAggregateInput'] = None,
        sum: Optional['types.WhatsappTemplateSumAggregateInput'] = None,
        min: Optional['types.WhatsappTemplateMinAggregateInput'] = None,
        max: Optional['types.WhatsappTemplateMaxAggregateInput'] = None,
        having: Optional['types.WhatsappTemplateScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.WhatsappTemplateCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.WhatsappTemplateScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.WhatsappTemplateScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.WhatsappTemplateGroupByOutput']:
        """Group WhatsappTemplate records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar WhatsappTemplate fields to group records by
        where
            WhatsappTemplate filter to select records
        take
            Limit the maximum number of WhatsappTemplate records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.WhatsappTemplateGroupByOutput]
            A list of dictionaries representing the WhatsappTemplate record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group WhatsappTemplate records by whatsappNumberId values
        # and count how many records are in each group
        results = await WhatsappTemplate.prisma().group_by(
            ['whatsappNumberId'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class LeadActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Lead]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Lead.prisma().query_raw(
            'SELECT * FROM Lead WHERE id = $1',
            'befcddgjce',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Lead
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Lead.prisma().query_first(
            'SELECT * FROM Lead WHERE firstName = $1',
            'bfhdbjjgfd',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.LeadCreateInput,
        include: Optional[types.LeadInclude] = None
    ) -> _PrismaModelT:
        """Create a new Lead record.

        Parameters
        ----------
        data
            Lead record data
        include
            Specifies which relations should be loaded on the returned Lead model

        Returns
        -------
        prisma.models.Lead
            The created Lead record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Lead record from just the required fields
        lead = await Lead.prisma().create(
            data={
                # data to create a Lead record
                'source': enums.LeadSource.FACEBOOK_COMMENT,
                'userId': 'cabdjadaji',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.LeadCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Lead records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Lead record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Lead.prisma().create_many(
            data=[
                {
                    # data to create a Lead record
                    'source': enums.LeadSource.FACEBOOK_COMMENT,
                    'userId': 'faajgfadf',
                },
                {
                    # data to create a Lead record
                    'source': enums.LeadSource.FACEBOOK_COMMENT,
                    'userId': 'biaagcedjc',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.LeadWhereUniqueInput,
        include: Optional[types.LeadInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Lead record.

        Parameters
        ----------
        where
            Lead filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Lead model

        Returns
        -------
        prisma.models.Lead
            The deleted Lead record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        lead = await Lead.prisma().delete(
            where={
                'id': 'cahhaghecf',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.LeadWhereUniqueInput,
        include: Optional[types.LeadInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Lead record.

        Parameters
        ----------
        where
            Lead filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Lead model

        Returns
        -------
        prisma.models.Lead
            The found Lead record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        lead = await Lead.prisma().find_unique(
            where={
                'id': 'bghcbbcidi',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.LeadWhereUniqueInput,
        include: Optional[types.LeadInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Lead record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Lead filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Lead model

        Returns
        -------
        prisma.models.Lead
            The found Lead record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        lead = await Lead.prisma().find_unique_or_raise(
            where={
                'id': 'jcgghhgdj',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LeadWhereInput] = None,
        cursor: Optional[types.LeadWhereUniqueInput] = None,
        include: Optional[types.LeadInclude] = None,
        order: Optional[Union[types.LeadOrderByInput, List[types.LeadOrderByInput]]] = None,
        distinct: Optional[List[types.LeadScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Lead records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Lead records returned
        skip
            Ignore the first N results
        where
            Lead filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Lead model
        order
            Order the returned Lead records by any field
        distinct
            Filter Lead records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Lead]
            The list of all Lead records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Lead records
        leads = await Lead.prisma().find_many(take=10)

        # find the first 5 Lead records ordered by the lastName field
        leads = await Lead.prisma().find_many(
            take=5,
            order={
                'lastName': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.LeadWhereInput] = None,
        cursor: Optional[types.LeadWhereUniqueInput] = None,
        include: Optional[types.LeadInclude] = None,
        order: Optional[Union[types.LeadOrderByInput, List[types.LeadOrderByInput]]] = None,
        distinct: Optional[List[types.LeadScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Lead record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Lead filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Lead model
        order
            Order the returned Lead records by any field
        distinct
            Filter Lead records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Lead
            The first Lead record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Lead record ordered by the email field
        lead = await Lead.prisma().find_first(
            skip=1,
            order={
                'email': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.LeadWhereInput] = None,
        cursor: Optional[types.LeadWhereUniqueInput] = None,
        include: Optional[types.LeadInclude] = None,
        order: Optional[Union[types.LeadOrderByInput, List[types.LeadOrderByInput]]] = None,
        distinct: Optional[List[types.LeadScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Lead record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Lead filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Lead model
        order
            Order the returned Lead records by any field
        distinct
            Filter Lead records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Lead
            The first Lead record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Lead record ordered by the phoneNumber field
        lead = await Lead.prisma().find_first_or_raise(
            skip=1,
            order={
                'phoneNumber': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.LeadUpdateInput,
        where: types.LeadWhereUniqueInput,
        include: Optional[types.LeadInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Lead record.

        Parameters
        ----------
        data
            Lead record data specifying what to update
        where
            Lead filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Lead model

        Returns
        -------
        prisma.models.Lead
            The updated Lead record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        lead = await Lead.prisma().update(
            where={
                'id': 'beehgcebbg',
            },
            data={
                # data to update the Lead record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.LeadWhereUniqueInput,
        data: types.LeadUpsertInput,
        include: Optional[types.LeadInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Lead filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Lead model

        Returns
        -------
        prisma.models.Lead
            The created or updated Lead record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        lead = await Lead.prisma().upsert(
            where={
                'id': 'bhdiaidiaf',
            },
            data={
                'create': {
                    'id': 'bhdiaidiaf',
                    'source': enums.LeadSource.FACEBOOK_COMMENT,
                    'userId': 'biaagcedjc',
                },
                'update': {
                    'source': enums.LeadSource.FACEBOOK_COMMENT,
                    'userId': 'biaagcedjc',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.LeadUpdateManyMutationInput,
        where: types.LeadWhereInput,
    ) -> int:
        """Update multiple Lead records

        Parameters
        ----------
        data
            Lead data to update the selected Lead records to
        where
            Filter to select the Lead records to update

        Returns
        -------
        int
            The total number of Lead records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Lead records
        total = await Lead.prisma().update_many(
            data={
                'facebookUserId': 'deajegcfi'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LeadWhereInput] = None,
        cursor: Optional[types.LeadWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Lead records present in the database

        Parameters
        ----------
        select
            Select the Lead fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Lead filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.LeadCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Lead.prisma().count()

        # results: prisma.types.LeadCountAggregateOutput
        results = await Lead.prisma().count(
            select={
                '_all': True,
                'source': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.LeadCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LeadWhereInput] = None,
        cursor: Optional[types.LeadWhereUniqueInput] = None,
    ) -> types.LeadCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.LeadCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LeadWhereInput] = None,
        cursor: Optional[types.LeadWhereUniqueInput] = None,
    ) -> Union[int, types.LeadCountAggregateOutput]:
        """Count the number of Lead records present in the database

        Parameters
        ----------
        select
            Select the Lead fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Lead filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.LeadCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Lead.prisma().count()

        # results: prisma.types.LeadCountAggregateOutput
        results = await Lead.prisma().count(
            select={
                '_all': True,
                'status': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.LeadCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.LeadWhereInput] = None
    ) -> int:
        """Delete multiple Lead records.

        Parameters
        ----------
        where
            Optional Lead filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Lead records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Lead records
        total = await Lead.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.LeadScalarFieldKeys'],
        *,
        where: Optional['types.LeadWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.LeadAvgAggregateInput'] = None,
        sum: Optional['types.LeadSumAggregateInput'] = None,
        min: Optional['types.LeadMinAggregateInput'] = None,
        max: Optional['types.LeadMaxAggregateInput'] = None,
        having: Optional['types.LeadScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.LeadCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.LeadScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.LeadScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.LeadGroupByOutput']:
        """Group Lead records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Lead fields to group records by
        where
            Lead filter to select records
        take
            Limit the maximum number of Lead records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.LeadGroupByOutput]
            A list of dictionaries representing the Lead record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Lead records by consentGiven values
        # and count how many records are in each group
        results = await Lead.prisma().group_by(
            ['consentGiven'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class TagActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Tag]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Tag.prisma().query_raw(
            'SELECT * FROM Tag WHERE id = $1',
            'gabahhhjf',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Tag
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Tag.prisma().query_first(
            'SELECT * FROM Tag WHERE name = $1',
            'cjagadcjg',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.TagCreateInput,
        include: Optional[types.TagInclude] = None
    ) -> _PrismaModelT:
        """Create a new Tag record.

        Parameters
        ----------
        data
            Tag record data
        include
            Specifies which relations should be loaded on the returned Tag model

        Returns
        -------
        prisma.models.Tag
            The created Tag record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Tag record from just the required fields
        tag = await Tag.prisma().create(
            data={
                # data to create a Tag record
                'name': 'bifficggej',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.TagCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Tag records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Tag record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Tag.prisma().create_many(
            data=[
                {
                    # data to create a Tag record
                    'name': 'bgbbaajbic',
                },
                {
                    # data to create a Tag record
                    'name': 'eegghdhjb',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.TagWhereUniqueInput,
        include: Optional[types.TagInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Tag record.

        Parameters
        ----------
        where
            Tag filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Tag model

        Returns
        -------
        prisma.models.Tag
            The deleted Tag record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        tag = await Tag.prisma().delete(
            where={
                'id': 'daafgidjg',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.TagWhereUniqueInput,
        include: Optional[types.TagInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Tag record.

        Parameters
        ----------
        where
            Tag filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Tag model

        Returns
        -------
        prisma.models.Tag
            The found Tag record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        tag = await Tag.prisma().find_unique(
            where={
                'id': 'gdcgcgagj',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.TagWhereUniqueInput,
        include: Optional[types.TagInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Tag record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Tag filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Tag model

        Returns
        -------
        prisma.models.Tag
            The found Tag record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        tag = await Tag.prisma().find_unique_or_raise(
            where={
                'id': 'bhceabbgja',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TagWhereInput] = None,
        cursor: Optional[types.TagWhereUniqueInput] = None,
        include: Optional[types.TagInclude] = None,
        order: Optional[Union[types.TagOrderByInput, List[types.TagOrderByInput]]] = None,
        distinct: Optional[List[types.TagScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Tag records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Tag records returned
        skip
            Ignore the first N results
        where
            Tag filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Tag model
        order
            Order the returned Tag records by any field
        distinct
            Filter Tag records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Tag]
            The list of all Tag records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Tag records
        tags = await Tag.prisma().find_many(take=10)

        # find the first 5 Tag records ordered by the color field
        tags = await Tag.prisma().find_many(
            take=5,
            order={
                'color': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.TagWhereInput] = None,
        cursor: Optional[types.TagWhereUniqueInput] = None,
        include: Optional[types.TagInclude] = None,
        order: Optional[Union[types.TagOrderByInput, List[types.TagOrderByInput]]] = None,
        distinct: Optional[List[types.TagScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Tag record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Tag filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Tag model
        order
            Order the returned Tag records by any field
        distinct
            Filter Tag records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Tag
            The first Tag record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Tag record ordered by the createdAt field
        tag = await Tag.prisma().find_first(
            skip=1,
            order={
                'createdAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.TagWhereInput] = None,
        cursor: Optional[types.TagWhereUniqueInput] = None,
        include: Optional[types.TagInclude] = None,
        order: Optional[Union[types.TagOrderByInput, List[types.TagOrderByInput]]] = None,
        distinct: Optional[List[types.TagScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Tag record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Tag filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Tag model
        order
            Order the returned Tag records by any field
        distinct
            Filter Tag records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Tag
            The first Tag record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Tag record ordered by the updatedAt field
        tag = await Tag.prisma().find_first_or_raise(
            skip=1,
            order={
                'updatedAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.TagUpdateInput,
        where: types.TagWhereUniqueInput,
        include: Optional[types.TagInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Tag record.

        Parameters
        ----------
        data
            Tag record data specifying what to update
        where
            Tag filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Tag model

        Returns
        -------
        prisma.models.Tag
            The updated Tag record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        tag = await Tag.prisma().update(
            where={
                'id': 'ehabfhegh',
            },
            data={
                # data to update the Tag record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.TagWhereUniqueInput,
        data: types.TagUpsertInput,
        include: Optional[types.TagInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Tag filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Tag model

        Returns
        -------
        prisma.models.Tag
            The created or updated Tag record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        tag = await Tag.prisma().upsert(
            where={
                'id': 'bcajcajjbc',
            },
            data={
                'create': {
                    'id': 'bcajcajjbc',
                    'name': 'eegghdhjb',
                },
                'update': {
                    'name': 'eegghdhjb',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.TagUpdateManyMutationInput,
        where: types.TagWhereInput,
    ) -> int:
        """Update multiple Tag records

        Parameters
        ----------
        data
            Tag data to update the selected Tag records to
        where
            Filter to select the Tag records to update

        Returns
        -------
        int
            The total number of Tag records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Tag records
        total = await Tag.prisma().update_many(
            data={
                'id': 'bfdgheeegf'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TagWhereInput] = None,
        cursor: Optional[types.TagWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Tag records present in the database

        Parameters
        ----------
        select
            Select the Tag fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Tag filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.TagCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Tag.prisma().count()

        # results: prisma.types.TagCountAggregateOutput
        results = await Tag.prisma().count(
            select={
                '_all': True,
                'name': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.TagCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TagWhereInput] = None,
        cursor: Optional[types.TagWhereUniqueInput] = None,
    ) -> types.TagCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.TagCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TagWhereInput] = None,
        cursor: Optional[types.TagWhereUniqueInput] = None,
    ) -> Union[int, types.TagCountAggregateOutput]:
        """Count the number of Tag records present in the database

        Parameters
        ----------
        select
            Select the Tag fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Tag filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.TagCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Tag.prisma().count()

        # results: prisma.types.TagCountAggregateOutput
        results = await Tag.prisma().count(
            select={
                '_all': True,
                'color': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.TagCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.TagWhereInput] = None
    ) -> int:
        """Delete multiple Tag records.

        Parameters
        ----------
        where
            Optional Tag filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Tag records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Tag records
        total = await Tag.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.TagScalarFieldKeys'],
        *,
        where: Optional['types.TagWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.TagAvgAggregateInput'] = None,
        sum: Optional['types.TagSumAggregateInput'] = None,
        min: Optional['types.TagMinAggregateInput'] = None,
        max: Optional['types.TagMaxAggregateInput'] = None,
        having: Optional['types.TagScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.TagCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.TagScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.TagScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.TagGroupByOutput']:
        """Group Tag records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Tag fields to group records by
        where
            Tag filter to select records
        take
            Limit the maximum number of Tag records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.TagGroupByOutput]
            A list of dictionaries representing the Tag record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Tag records by createdAt values
        # and count how many records are in each group
        results = await Tag.prisma().group_by(
            ['createdAt'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class LeadTagActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.LeadTag]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await LeadTag.prisma().query_raw(
            'SELECT * FROM LeadTag WHERE leadId = $1',
            'ececbijji',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.LeadTag
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await LeadTag.prisma().query_first(
            'SELECT * FROM LeadTag WHERE tagId = $1',
            'cbcfgdcdhf',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.LeadTagCreateInput,
        include: Optional[types.LeadTagInclude] = None
    ) -> _PrismaModelT:
        """Create a new LeadTag record.

        Parameters
        ----------
        data
            LeadTag record data
        include
            Specifies which relations should be loaded on the returned LeadTag model

        Returns
        -------
        prisma.models.LeadTag
            The created LeadTag record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a LeadTag record from just the required fields
        leadtag = await LeadTag.prisma().create(
            data={
                # data to create a LeadTag record
                'leadId': 'fdgjfbhia',
                'tagId': 'jcehcdchh',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.LeadTagCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple LeadTag records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of LeadTag record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await LeadTag.prisma().create_many(
            data=[
                {
                    # data to create a LeadTag record
                    'leadId': 'bgcbjdhjcc',
                    'tagId': 'bieiidcabj',
                },
                {
                    # data to create a LeadTag record
                    'leadId': 'bjcbfcieaa',
                    'tagId': 'cbaaechiej',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.LeadTagWhereUniqueInput,
        include: Optional[types.LeadTagInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single LeadTag record.

        Parameters
        ----------
        where
            LeadTag filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned LeadTag model

        Returns
        -------
        prisma.models.LeadTag
            The deleted LeadTag record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        leadtag = await LeadTag.prisma().delete(
            where={
                # LeadTag where unique filter

            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.LeadTagWhereUniqueInput,
        include: Optional[types.LeadTagInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique LeadTag record.

        Parameters
        ----------
        where
            LeadTag filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned LeadTag model

        Returns
        -------
        prisma.models.LeadTag
            The found LeadTag record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        leadtag = await LeadTag.prisma().find_unique(
            where={
                # LeadTag where unique filter

            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.LeadTagWhereUniqueInput,
        include: Optional[types.LeadTagInclude] = None
    ) -> _PrismaModelT:
        """Find a unique LeadTag record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            LeadTag filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned LeadTag model

        Returns
        -------
        prisma.models.LeadTag
            The found LeadTag record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        leadtag = await LeadTag.prisma().find_unique_or_raise(
            where={
                # LeadTag where unique filter

            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LeadTagWhereInput] = None,
        cursor: Optional[types.LeadTagWhereUniqueInput] = None,
        include: Optional[types.LeadTagInclude] = None,
        order: Optional[Union[types.LeadTagOrderByInput, List[types.LeadTagOrderByInput]]] = None,
        distinct: Optional[List[types.LeadTagScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple LeadTag records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of LeadTag records returned
        skip
            Ignore the first N results
        where
            LeadTag filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned LeadTag model
        order
            Order the returned LeadTag records by any field
        distinct
            Filter LeadTag records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.LeadTag]
            The list of all LeadTag records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 LeadTag records
        leadtags = await LeadTag.prisma().find_many(take=10)

        # find the first 5 LeadTag records ordered by the createdAt field
        leadtags = await LeadTag.prisma().find_many(
            take=5,
            order={
                'createdAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.LeadTagWhereInput] = None,
        cursor: Optional[types.LeadTagWhereUniqueInput] = None,
        include: Optional[types.LeadTagInclude] = None,
        order: Optional[Union[types.LeadTagOrderByInput, List[types.LeadTagOrderByInput]]] = None,
        distinct: Optional[List[types.LeadTagScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single LeadTag record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            LeadTag filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned LeadTag model
        order
            Order the returned LeadTag records by any field
        distinct
            Filter LeadTag records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.LeadTag
            The first LeadTag record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second LeadTag record ordered by the leadId field
        leadtag = await LeadTag.prisma().find_first(
            skip=1,
            order={
                'leadId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.LeadTagWhereInput] = None,
        cursor: Optional[types.LeadTagWhereUniqueInput] = None,
        include: Optional[types.LeadTagInclude] = None,
        order: Optional[Union[types.LeadTagOrderByInput, List[types.LeadTagOrderByInput]]] = None,
        distinct: Optional[List[types.LeadTagScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single LeadTag record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            LeadTag filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned LeadTag model
        order
            Order the returned LeadTag records by any field
        distinct
            Filter LeadTag records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.LeadTag
            The first LeadTag record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second LeadTag record ordered by the tagId field
        leadtag = await LeadTag.prisma().find_first_or_raise(
            skip=1,
            order={
                'tagId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.LeadTagUpdateInput,
        where: types.LeadTagWhereUniqueInput,
        include: Optional[types.LeadTagInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single LeadTag record.

        Parameters
        ----------
        data
            LeadTag record data specifying what to update
        where
            LeadTag filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned LeadTag model

        Returns
        -------
        prisma.models.LeadTag
            The updated LeadTag record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        leadtag = await LeadTag.prisma().update(
            where={
                # LeadTag where unique filter

            },
            data={
                # data to update the LeadTag record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.LeadTagWhereUniqueInput,
        data: types.LeadTagUpsertInput,
        include: Optional[types.LeadTagInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            LeadTag filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned LeadTag model

        Returns
        -------
        prisma.models.LeadTag
            The created or updated LeadTag record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        leadtag = await LeadTag.prisma().upsert(
            where={
                # LeadTag where unique filter
            },
            data={
                'create': {
                    # LeadTag data to be set if the record does not exist
                },
                'update': {
                    # LeadTag data to be set if the record does exist
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.LeadTagUpdateManyMutationInput,
        where: types.LeadTagWhereInput,
    ) -> int:
        """Update multiple LeadTag records

        Parameters
        ----------
        data
            LeadTag data to update the selected LeadTag records to
        where
            Filter to select the LeadTag records to update

        Returns
        -------
        int
            The total number of LeadTag records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all LeadTag records
        total = await LeadTag.prisma().update_many(
            data={
                'createdAt': datetime.datetime.utcnow()
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LeadTagWhereInput] = None,
        cursor: Optional[types.LeadTagWhereUniqueInput] = None,
    ) -> int:
        """Count the number of LeadTag records present in the database

        Parameters
        ----------
        select
            Select the LeadTag fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            LeadTag filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.LeadTagCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await LeadTag.prisma().count()

        # results: prisma.types.LeadTagCountAggregateOutput
        results = await LeadTag.prisma().count(
            select={
                '_all': True,
                'leadId': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.LeadTagCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LeadTagWhereInput] = None,
        cursor: Optional[types.LeadTagWhereUniqueInput] = None,
    ) -> types.LeadTagCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.LeadTagCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.LeadTagWhereInput] = None,
        cursor: Optional[types.LeadTagWhereUniqueInput] = None,
    ) -> Union[int, types.LeadTagCountAggregateOutput]:
        """Count the number of LeadTag records present in the database

        Parameters
        ----------
        select
            Select the LeadTag fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            LeadTag filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.LeadTagCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await LeadTag.prisma().count()

        # results: prisma.types.LeadTagCountAggregateOutput
        results = await LeadTag.prisma().count(
            select={
                '_all': True,
                'tagId': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.LeadTagCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.LeadTagWhereInput] = None
    ) -> int:
        """Delete multiple LeadTag records.

        Parameters
        ----------
        where
            Optional LeadTag filter to find the records to be deleted

        Returns
        -------
        int
            The total number of LeadTag records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all LeadTag records
        total = await LeadTag.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.LeadTagScalarFieldKeys'],
        *,
        where: Optional['types.LeadTagWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.LeadTagAvgAggregateInput'] = None,
        sum: Optional['types.LeadTagSumAggregateInput'] = None,
        min: Optional['types.LeadTagMinAggregateInput'] = None,
        max: Optional['types.LeadTagMaxAggregateInput'] = None,
        having: Optional['types.LeadTagScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.LeadTagCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.LeadTagScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.LeadTagScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.LeadTagGroupByOutput']:
        """Group LeadTag records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar LeadTag fields to group records by
        where
            LeadTag filter to select records
        take
            Limit the maximum number of LeadTag records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.LeadTagGroupByOutput]
            A list of dictionaries representing the LeadTag record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group LeadTag records by createdAt values
        # and count how many records are in each group
        results = await LeadTag.prisma().group_by(
            ['createdAt'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class MessageActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Message]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Message.prisma().query_raw(
            'SELECT * FROM Message WHERE id = $1',
            'iejbeaaeg',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Message
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Message.prisma().query_first(
            'SELECT * FROM Message WHERE type = $1',
            enums.MessageType.TEXT,
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.MessageCreateInput,
        include: Optional[types.MessageInclude] = None
    ) -> _PrismaModelT:
        """Create a new Message record.

        Parameters
        ----------
        data
            Message record data
        include
            Specifies which relations should be loaded on the returned Message model

        Returns
        -------
        prisma.models.Message
            The created Message record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Message record from just the required fields
        message = await Message.prisma().create(
            data={
                # data to create a Message record
                'type': enums.MessageType.TEXT,
                'platform': enums.MessagePlatform.WHATSAPP,
                'recipient': 'jcibfcbhf',
                'content': 'chdadcaga',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.MessageCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Message records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Message record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Message.prisma().create_many(
            data=[
                {
                    # data to create a Message record
                    'type': enums.MessageType.TEXT,
                    'platform': enums.MessagePlatform.WHATSAPP,
                    'recipient': 'jicieifbh',
                    'content': 'fbahdheji',
                },
                {
                    # data to create a Message record
                    'type': enums.MessageType.TEXT,
                    'platform': enums.MessagePlatform.WHATSAPP,
                    'recipient': 'cbbheiicgh',
                    'content': 'beabjeejdg',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.MessageWhereUniqueInput,
        include: Optional[types.MessageInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Message record.

        Parameters
        ----------
        where
            Message filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Message model

        Returns
        -------
        prisma.models.Message
            The deleted Message record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        message = await Message.prisma().delete(
            where={
                'id': 'bcjhgahffd',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.MessageWhereUniqueInput,
        include: Optional[types.MessageInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Message record.

        Parameters
        ----------
        where
            Message filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Message model

        Returns
        -------
        prisma.models.Message
            The found Message record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        message = await Message.prisma().find_unique(
            where={
                'id': 'fbjeiiffa',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.MessageWhereUniqueInput,
        include: Optional[types.MessageInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Message record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Message filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Message model

        Returns
        -------
        prisma.models.Message
            The found Message record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        message = await Message.prisma().find_unique_or_raise(
            where={
                'id': 'jhgidcgbf',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.MessageWhereInput] = None,
        cursor: Optional[types.MessageWhereUniqueInput] = None,
        include: Optional[types.MessageInclude] = None,
        order: Optional[Union[types.MessageOrderByInput, List[types.MessageOrderByInput]]] = None,
        distinct: Optional[List[types.MessageScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Message records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Message records returned
        skip
            Ignore the first N results
        where
            Message filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Message model
        order
            Order the returned Message records by any field
        distinct
            Filter Message records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Message]
            The list of all Message records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Message records
        messages = await Message.prisma().find_many(take=10)

        # find the first 5 Message records ordered by the platform field
        messages = await Message.prisma().find_many(
            take=5,
            order={
                'platform': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.MessageWhereInput] = None,
        cursor: Optional[types.MessageWhereUniqueInput] = None,
        include: Optional[types.MessageInclude] = None,
        order: Optional[Union[types.MessageOrderByInput, List[types.MessageOrderByInput]]] = None,
        distinct: Optional[List[types.MessageScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Message record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Message filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Message model
        order
            Order the returned Message records by any field
        distinct
            Filter Message records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Message
            The first Message record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Message record ordered by the recipient field
        message = await Message.prisma().find_first(
            skip=1,
            order={
                'recipient': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.MessageWhereInput] = None,
        cursor: Optional[types.MessageWhereUniqueInput] = None,
        include: Optional[types.MessageInclude] = None,
        order: Optional[Union[types.MessageOrderByInput, List[types.MessageOrderByInput]]] = None,
        distinct: Optional[List[types.MessageScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Message record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Message filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Message model
        order
            Order the returned Message records by any field
        distinct
            Filter Message records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Message
            The first Message record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Message record ordered by the content field
        message = await Message.prisma().find_first_or_raise(
            skip=1,
            order={
                'content': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.MessageUpdateInput,
        where: types.MessageWhereUniqueInput,
        include: Optional[types.MessageInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Message record.

        Parameters
        ----------
        data
            Message record data specifying what to update
        where
            Message filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Message model

        Returns
        -------
        prisma.models.Message
            The updated Message record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        message = await Message.prisma().update(
            where={
                'id': 'bgjgecfejc',
            },
            data={
                # data to update the Message record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.MessageWhereUniqueInput,
        data: types.MessageUpsertInput,
        include: Optional[types.MessageInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Message filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Message model

        Returns
        -------
        prisma.models.Message
            The created or updated Message record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        message = await Message.prisma().upsert(
            where={
                'id': 'bgjcgchib',
            },
            data={
                'create': {
                    'id': 'bgjcgchib',
                    'type': enums.MessageType.TEXT,
                    'platform': enums.MessagePlatform.WHATSAPP,
                    'recipient': 'cbbheiicgh',
                    'content': 'beabjeejdg',
                },
                'update': {
                    'type': enums.MessageType.TEXT,
                    'platform': enums.MessagePlatform.WHATSAPP,
                    'recipient': 'cbbheiicgh',
                    'content': 'beabjeejdg',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.MessageUpdateManyMutationInput,
        where: types.MessageWhereInput,
    ) -> int:
        """Update multiple Message records

        Parameters
        ----------
        data
            Message data to update the selected Message records to
        where
            Filter to select the Message records to update

        Returns
        -------
        int
            The total number of Message records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Message records
        total = await Message.prisma().update_many(
            data={
                'status': enums.MessageStatus.PENDING
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.MessageWhereInput] = None,
        cursor: Optional[types.MessageWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Message records present in the database

        Parameters
        ----------
        select
            Select the Message fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Message filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.MessageCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Message.prisma().count()

        # results: prisma.types.MessageCountAggregateOutput
        results = await Message.prisma().count(
            select={
                '_all': True,
                'sentAt': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.MessageCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.MessageWhereInput] = None,
        cursor: Optional[types.MessageWhereUniqueInput] = None,
    ) -> types.MessageCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.MessageCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.MessageWhereInput] = None,
        cursor: Optional[types.MessageWhereUniqueInput] = None,
    ) -> Union[int, types.MessageCountAggregateOutput]:
        """Count the number of Message records present in the database

        Parameters
        ----------
        select
            Select the Message fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Message filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.MessageCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Message.prisma().count()

        # results: prisma.types.MessageCountAggregateOutput
        results = await Message.prisma().count(
            select={
                '_all': True,
                'deliveredAt': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.MessageCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.MessageWhereInput] = None
    ) -> int:
        """Delete multiple Message records.

        Parameters
        ----------
        where
            Optional Message filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Message records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Message records
        total = await Message.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.MessageScalarFieldKeys'],
        *,
        where: Optional['types.MessageWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.MessageAvgAggregateInput'] = None,
        sum: Optional['types.MessageSumAggregateInput'] = None,
        min: Optional['types.MessageMinAggregateInput'] = None,
        max: Optional['types.MessageMaxAggregateInput'] = None,
        having: Optional['types.MessageScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.MessageCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.MessageScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.MessageScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.MessageGroupByOutput']:
        """Group Message records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Message fields to group records by
        where
            Message filter to select records
        take
            Limit the maximum number of Message records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.MessageGroupByOutput]
            A list of dictionaries representing the Message record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Message records by readAt values
        # and count how many records are in each group
        results = await Message.prisma().group_by(
            ['readAt'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class CampaignActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Campaign]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Campaign.prisma().query_raw(
            'SELECT * FROM Campaign WHERE id = $1',
            'bacdaibgfa',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Campaign
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Campaign.prisma().query_first(
            'SELECT * FROM Campaign WHERE name = $1',
            'dchgibach',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.CampaignCreateInput,
        include: Optional[types.CampaignInclude] = None
    ) -> _PrismaModelT:
        """Create a new Campaign record.

        Parameters
        ----------
        data
            Campaign record data
        include
            Specifies which relations should be loaded on the returned Campaign model

        Returns
        -------
        prisma.models.Campaign
            The created Campaign record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Campaign record from just the required fields
        campaign = await Campaign.prisma().create(
            data={
                # data to create a Campaign record
                'name': 'fchheijjc',
                'type': enums.CampaignType.WHATSAPP_TEMPLATE,
                'targetAudience': Json({'cacjdfhejh': True}),
                'messageTemplate': 'bdbifjhbbi',
                'userId': 'cbccbbcdfb',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.CampaignCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Campaign records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Campaign record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Campaign.prisma().create_many(
            data=[
                {
                    # data to create a Campaign record
                    'name': 'bacejedaca',
                    'type': enums.CampaignType.WHATSAPP_TEMPLATE,
                    'targetAudience': Json({'bhbhdahfaj': True}),
                    'messageTemplate': 'bfjibceaec',
                    'userId': 'ibhgcdbgd',
                },
                {
                    # data to create a Campaign record
                    'name': 'badaffhddg',
                    'type': enums.CampaignType.WHATSAPP_TEMPLATE,
                    'targetAudience': Json({'bbdbfcfihd': True}),
                    'messageTemplate': 'cbagggbji',
                    'userId': 'bchgafhjed',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.CampaignWhereUniqueInput,
        include: Optional[types.CampaignInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Campaign record.

        Parameters
        ----------
        where
            Campaign filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Campaign model

        Returns
        -------
        prisma.models.Campaign
            The deleted Campaign record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        campaign = await Campaign.prisma().delete(
            where={
                'id': 'heffgjdei',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.CampaignWhereUniqueInput,
        include: Optional[types.CampaignInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Campaign record.

        Parameters
        ----------
        where
            Campaign filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Campaign model

        Returns
        -------
        prisma.models.Campaign
            The found Campaign record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        campaign = await Campaign.prisma().find_unique(
            where={
                'id': 'dahihgbeb',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.CampaignWhereUniqueInput,
        include: Optional[types.CampaignInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Campaign record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Campaign filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Campaign model

        Returns
        -------
        prisma.models.Campaign
            The found Campaign record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        campaign = await Campaign.prisma().find_unique_or_raise(
            where={
                'id': 'bgheaejbcc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CampaignWhereInput] = None,
        cursor: Optional[types.CampaignWhereUniqueInput] = None,
        include: Optional[types.CampaignInclude] = None,
        order: Optional[Union[types.CampaignOrderByInput, List[types.CampaignOrderByInput]]] = None,
        distinct: Optional[List[types.CampaignScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Campaign records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Campaign records returned
        skip
            Ignore the first N results
        where
            Campaign filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Campaign model
        order
            Order the returned Campaign records by any field
        distinct
            Filter Campaign records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Campaign]
            The list of all Campaign records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Campaign records
        campaigns = await Campaign.prisma().find_many(take=10)

        # find the first 5 Campaign records ordered by the description field
        campaigns = await Campaign.prisma().find_many(
            take=5,
            order={
                'description': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.CampaignWhereInput] = None,
        cursor: Optional[types.CampaignWhereUniqueInput] = None,
        include: Optional[types.CampaignInclude] = None,
        order: Optional[Union[types.CampaignOrderByInput, List[types.CampaignOrderByInput]]] = None,
        distinct: Optional[List[types.CampaignScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Campaign record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Campaign filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Campaign model
        order
            Order the returned Campaign records by any field
        distinct
            Filter Campaign records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Campaign
            The first Campaign record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Campaign record ordered by the type field
        campaign = await Campaign.prisma().find_first(
            skip=1,
            order={
                'type': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.CampaignWhereInput] = None,
        cursor: Optional[types.CampaignWhereUniqueInput] = None,
        include: Optional[types.CampaignInclude] = None,
        order: Optional[Union[types.CampaignOrderByInput, List[types.CampaignOrderByInput]]] = None,
        distinct: Optional[List[types.CampaignScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Campaign record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Campaign filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Campaign model
        order
            Order the returned Campaign records by any field
        distinct
            Filter Campaign records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Campaign
            The first Campaign record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Campaign record ordered by the status field
        campaign = await Campaign.prisma().find_first_or_raise(
            skip=1,
            order={
                'status': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.CampaignUpdateInput,
        where: types.CampaignWhereUniqueInput,
        include: Optional[types.CampaignInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Campaign record.

        Parameters
        ----------
        data
            Campaign record data specifying what to update
        where
            Campaign filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Campaign model

        Returns
        -------
        prisma.models.Campaign
            The updated Campaign record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        campaign = await Campaign.prisma().update(
            where={
                'id': 'bfcgifeged',
            },
            data={
                # data to update the Campaign record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.CampaignWhereUniqueInput,
        data: types.CampaignUpsertInput,
        include: Optional[types.CampaignInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Campaign filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Campaign model

        Returns
        -------
        prisma.models.Campaign
            The created or updated Campaign record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        campaign = await Campaign.prisma().upsert(
            where={
                'id': 'jfiahhbae',
            },
            data={
                'create': {
                    'id': 'jfiahhbae',
                    'name': 'badaffhddg',
                    'type': enums.CampaignType.WHATSAPP_TEMPLATE,
                    'targetAudience': Json({'bbdbfcfihd': True}),
                    'messageTemplate': 'cbagggbji',
                    'userId': 'bchgafhjed',
                },
                'update': {
                    'name': 'badaffhddg',
                    'type': enums.CampaignType.WHATSAPP_TEMPLATE,
                    'targetAudience': Json({'bbdbfcfihd': True}),
                    'messageTemplate': 'cbagggbji',
                    'userId': 'bchgafhjed',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.CampaignUpdateManyMutationInput,
        where: types.CampaignWhereInput,
    ) -> int:
        """Update multiple Campaign records

        Parameters
        ----------
        data
            Campaign data to update the selected Campaign records to
        where
            Filter to select the Campaign records to update

        Returns
        -------
        int
            The total number of Campaign records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Campaign records
        total = await Campaign.prisma().update_many(
            data={
                'scheduledAt': datetime.datetime.utcnow()
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CampaignWhereInput] = None,
        cursor: Optional[types.CampaignWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Campaign records present in the database

        Parameters
        ----------
        select
            Select the Campaign fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Campaign filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.CampaignCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Campaign.prisma().count()

        # results: prisma.types.CampaignCountAggregateOutput
        results = await Campaign.prisma().count(
            select={
                '_all': True,
                'startedAt': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.CampaignCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CampaignWhereInput] = None,
        cursor: Optional[types.CampaignWhereUniqueInput] = None,
    ) -> types.CampaignCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.CampaignCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CampaignWhereInput] = None,
        cursor: Optional[types.CampaignWhereUniqueInput] = None,
    ) -> Union[int, types.CampaignCountAggregateOutput]:
        """Count the number of Campaign records present in the database

        Parameters
        ----------
        select
            Select the Campaign fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Campaign filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.CampaignCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Campaign.prisma().count()

        # results: prisma.types.CampaignCountAggregateOutput
        results = await Campaign.prisma().count(
            select={
                '_all': True,
                'completedAt': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.CampaignCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.CampaignWhereInput] = None
    ) -> int:
        """Delete multiple Campaign records.

        Parameters
        ----------
        where
            Optional Campaign filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Campaign records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Campaign records
        total = await Campaign.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.CampaignScalarFieldKeys'],
        *,
        where: Optional['types.CampaignWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.CampaignAvgAggregateInput'] = None,
        sum: Optional['types.CampaignSumAggregateInput'] = None,
        min: Optional['types.CampaignMinAggregateInput'] = None,
        max: Optional['types.CampaignMaxAggregateInput'] = None,
        having: Optional['types.CampaignScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.CampaignCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.CampaignScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.CampaignScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.CampaignGroupByOutput']:
        """Group Campaign records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Campaign fields to group records by
        where
            Campaign filter to select records
        take
            Limit the maximum number of Campaign records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.CampaignGroupByOutput]
            A list of dictionaries representing the Campaign record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Campaign records by targetAudience values
        # and count how many records are in each group
        results = await Campaign.prisma().group_by(
            ['targetAudience'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class AuditLogActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.AuditLog]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await AuditLog.prisma().query_raw(
            'SELECT * FROM AuditLog WHERE id = $1',
            'bfbdafajcb',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.AuditLog
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await AuditLog.prisma().query_first(
            'SELECT * FROM AuditLog WHERE action = $1',
            'caeghehde',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.AuditLogCreateInput,
        include: Optional[types.AuditLogInclude] = None
    ) -> _PrismaModelT:
        """Create a new AuditLog record.

        Parameters
        ----------
        data
            AuditLog record data
        include
            Specifies which relations should be loaded on the returned AuditLog model

        Returns
        -------
        prisma.models.AuditLog
            The created AuditLog record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a AuditLog record from just the required fields
        auditlog = await AuditLog.prisma().create(
            data={
                # data to create a AuditLog record
                'action': 'caghgfbggd',
                'resource': 'bbidjbbjaa',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.AuditLogCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple AuditLog records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of AuditLog record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await AuditLog.prisma().create_many(
            data=[
                {
                    # data to create a AuditLog record
                    'action': 'bfijhaejdd',
                    'resource': 'bcedehfiji',
                },
                {
                    # data to create a AuditLog record
                    'action': 'bdgjicijhb',
                    'resource': 'bghifjdeia',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.AuditLogWhereUniqueInput,
        include: Optional[types.AuditLogInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single AuditLog record.

        Parameters
        ----------
        where
            AuditLog filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned AuditLog model

        Returns
        -------
        prisma.models.AuditLog
            The deleted AuditLog record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        auditlog = await AuditLog.prisma().delete(
            where={
                'id': 'eadfcbbcb',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.AuditLogWhereUniqueInput,
        include: Optional[types.AuditLogInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique AuditLog record.

        Parameters
        ----------
        where
            AuditLog filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned AuditLog model

        Returns
        -------
        prisma.models.AuditLog
            The found AuditLog record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        auditlog = await AuditLog.prisma().find_unique(
            where={
                'id': 'geihgahba',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.AuditLogWhereUniqueInput,
        include: Optional[types.AuditLogInclude] = None
    ) -> _PrismaModelT:
        """Find a unique AuditLog record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            AuditLog filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned AuditLog model

        Returns
        -------
        prisma.models.AuditLog
            The found AuditLog record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        auditlog = await AuditLog.prisma().find_unique_or_raise(
            where={
                'id': 'gahdcdhbj',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AuditLogWhereInput] = None,
        cursor: Optional[types.AuditLogWhereUniqueInput] = None,
        include: Optional[types.AuditLogInclude] = None,
        order: Optional[Union[types.AuditLogOrderByInput, List[types.AuditLogOrderByInput]]] = None,
        distinct: Optional[List[types.AuditLogScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple AuditLog records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of AuditLog records returned
        skip
            Ignore the first N results
        where
            AuditLog filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned AuditLog model
        order
            Order the returned AuditLog records by any field
        distinct
            Filter AuditLog records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.AuditLog]
            The list of all AuditLog records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 AuditLog records
        auditlogs = await AuditLog.prisma().find_many(take=10)

        # find the first 5 AuditLog records ordered by the resource field
        auditlogs = await AuditLog.prisma().find_many(
            take=5,
            order={
                'resource': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.AuditLogWhereInput] = None,
        cursor: Optional[types.AuditLogWhereUniqueInput] = None,
        include: Optional[types.AuditLogInclude] = None,
        order: Optional[Union[types.AuditLogOrderByInput, List[types.AuditLogOrderByInput]]] = None,
        distinct: Optional[List[types.AuditLogScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single AuditLog record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            AuditLog filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned AuditLog model
        order
            Order the returned AuditLog records by any field
        distinct
            Filter AuditLog records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.AuditLog
            The first AuditLog record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second AuditLog record ordered by the resourceId field
        auditlog = await AuditLog.prisma().find_first(
            skip=1,
            order={
                'resourceId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.AuditLogWhereInput] = None,
        cursor: Optional[types.AuditLogWhereUniqueInput] = None,
        include: Optional[types.AuditLogInclude] = None,
        order: Optional[Union[types.AuditLogOrderByInput, List[types.AuditLogOrderByInput]]] = None,
        distinct: Optional[List[types.AuditLogScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single AuditLog record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            AuditLog filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned AuditLog model
        order
            Order the returned AuditLog records by any field
        distinct
            Filter AuditLog records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.AuditLog
            The first AuditLog record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second AuditLog record ordered by the details field
        auditlog = await AuditLog.prisma().find_first_or_raise(
            skip=1,
            order={
                'details': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.AuditLogUpdateInput,
        where: types.AuditLogWhereUniqueInput,
        include: Optional[types.AuditLogInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single AuditLog record.

        Parameters
        ----------
        data
            AuditLog record data specifying what to update
        where
            AuditLog filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned AuditLog model

        Returns
        -------
        prisma.models.AuditLog
            The updated AuditLog record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        auditlog = await AuditLog.prisma().update(
            where={
                'id': 'begiijahea',
            },
            data={
                # data to update the AuditLog record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.AuditLogWhereUniqueInput,
        data: types.AuditLogUpsertInput,
        include: Optional[types.AuditLogInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            AuditLog filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned AuditLog model

        Returns
        -------
        prisma.models.AuditLog
            The created or updated AuditLog record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        auditlog = await AuditLog.prisma().upsert(
            where={
                'id': 'gcjadjaaf',
            },
            data={
                'create': {
                    'id': 'gcjadjaaf',
                    'action': 'bdgjicijhb',
                    'resource': 'bghifjdeia',
                },
                'update': {
                    'action': 'bdgjicijhb',
                    'resource': 'bghifjdeia',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.AuditLogUpdateManyMutationInput,
        where: types.AuditLogWhereInput,
    ) -> int:
        """Update multiple AuditLog records

        Parameters
        ----------
        data
            AuditLog data to update the selected AuditLog records to
        where
            Filter to select the AuditLog records to update

        Returns
        -------
        int
            The total number of AuditLog records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all AuditLog records
        total = await AuditLog.prisma().update_many(
            data={
                'ipAddress': 'bcbebgiaic'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AuditLogWhereInput] = None,
        cursor: Optional[types.AuditLogWhereUniqueInput] = None,
    ) -> int:
        """Count the number of AuditLog records present in the database

        Parameters
        ----------
        select
            Select the AuditLog fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            AuditLog filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.AuditLogCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await AuditLog.prisma().count()

        # results: prisma.types.AuditLogCountAggregateOutput
        results = await AuditLog.prisma().count(
            select={
                '_all': True,
                'userAgent': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.AuditLogCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AuditLogWhereInput] = None,
        cursor: Optional[types.AuditLogWhereUniqueInput] = None,
    ) -> types.AuditLogCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.AuditLogCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AuditLogWhereInput] = None,
        cursor: Optional[types.AuditLogWhereUniqueInput] = None,
    ) -> Union[int, types.AuditLogCountAggregateOutput]:
        """Count the number of AuditLog records present in the database

        Parameters
        ----------
        select
            Select the AuditLog fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            AuditLog filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.AuditLogCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await AuditLog.prisma().count()

        # results: prisma.types.AuditLogCountAggregateOutput
        results = await AuditLog.prisma().count(
            select={
                '_all': True,
                'createdAt': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.AuditLogCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.AuditLogWhereInput] = None
    ) -> int:
        """Delete multiple AuditLog records.

        Parameters
        ----------
        where
            Optional AuditLog filter to find the records to be deleted

        Returns
        -------
        int
            The total number of AuditLog records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all AuditLog records
        total = await AuditLog.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.AuditLogScalarFieldKeys'],
        *,
        where: Optional['types.AuditLogWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.AuditLogAvgAggregateInput'] = None,
        sum: Optional['types.AuditLogSumAggregateInput'] = None,
        min: Optional['types.AuditLogMinAggregateInput'] = None,
        max: Optional['types.AuditLogMaxAggregateInput'] = None,
        having: Optional['types.AuditLogScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.AuditLogCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.AuditLogScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.AuditLogScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.AuditLogGroupByOutput']:
        """Group AuditLog records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar AuditLog fields to group records by
        where
            AuditLog filter to select records
        take
            Limit the maximum number of AuditLog records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.AuditLogGroupByOutput]
            A list of dictionaries representing the AuditLog record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group AuditLog records by userId values
        # and count how many records are in each group
        results = await AuditLog.prisma().group_by(
            ['userId'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class ApiKeyActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.ApiKey]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await ApiKey.prisma().query_raw(
            'SELECT * FROM ApiKey WHERE id = $1',
            'ijigbdcbj',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.ApiKey
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await ApiKey.prisma().query_first(
            'SELECT * FROM ApiKey WHERE name = $1',
            'gfidhicai',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.ApiKeyCreateInput,
        include: Optional[types.ApiKeyInclude] = None
    ) -> _PrismaModelT:
        """Create a new ApiKey record.

        Parameters
        ----------
        data
            ApiKey record data
        include
            Specifies which relations should be loaded on the returned ApiKey model

        Returns
        -------
        prisma.models.ApiKey
            The created ApiKey record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a ApiKey record from just the required fields
        apikey = await ApiKey.prisma().create(
            data={
                # data to create a ApiKey record
                'name': 'jfegcaafh',
                'keyHash': 'bcbeiajjfa',
                'permissions': Json({'baehicaajf': True}),
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.ApiKeyCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple ApiKey records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of ApiKey record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await ApiKey.prisma().create_many(
            data=[
                {
                    # data to create a ApiKey record
                    'name': 'bdachdeiga',
                    'keyHash': 'ijdafccef',
                    'permissions': Json({'ciaaiddag': True}),
                },
                {
                    # data to create a ApiKey record
                    'name': 'fejggijff',
                    'keyHash': 'hghjaaai',
                    'permissions': Json({'cajicjjdef': True}),
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.ApiKeyWhereUniqueInput,
        include: Optional[types.ApiKeyInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single ApiKey record.

        Parameters
        ----------
        where
            ApiKey filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned ApiKey model

        Returns
        -------
        prisma.models.ApiKey
            The deleted ApiKey record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        apikey = await ApiKey.prisma().delete(
            where={
                'id': 'cefjaadec',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.ApiKeyWhereUniqueInput,
        include: Optional[types.ApiKeyInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique ApiKey record.

        Parameters
        ----------
        where
            ApiKey filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned ApiKey model

        Returns
        -------
        prisma.models.ApiKey
            The found ApiKey record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        apikey = await ApiKey.prisma().find_unique(
            where={
                'id': 'ibbigdigd',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.ApiKeyWhereUniqueInput,
        include: Optional[types.ApiKeyInclude] = None
    ) -> _PrismaModelT:
        """Find a unique ApiKey record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            ApiKey filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned ApiKey model

        Returns
        -------
        prisma.models.ApiKey
            The found ApiKey record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        apikey = await ApiKey.prisma().find_unique_or_raise(
            where={
                'id': 'bdiiiabbii',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ApiKeyWhereInput] = None,
        cursor: Optional[types.ApiKeyWhereUniqueInput] = None,
        include: Optional[types.ApiKeyInclude] = None,
        order: Optional[Union[types.ApiKeyOrderByInput, List[types.ApiKeyOrderByInput]]] = None,
        distinct: Optional[List[types.ApiKeyScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple ApiKey records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of ApiKey records returned
        skip
            Ignore the first N results
        where
            ApiKey filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ApiKey model
        order
            Order the returned ApiKey records by any field
        distinct
            Filter ApiKey records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.ApiKey]
            The list of all ApiKey records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 ApiKey records
        apikeys = await ApiKey.prisma().find_many(take=10)

        # find the first 5 ApiKey records ordered by the keyHash field
        apikeys = await ApiKey.prisma().find_many(
            take=5,
            order={
                'keyHash': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ApiKeyWhereInput] = None,
        cursor: Optional[types.ApiKeyWhereUniqueInput] = None,
        include: Optional[types.ApiKeyInclude] = None,
        order: Optional[Union[types.ApiKeyOrderByInput, List[types.ApiKeyOrderByInput]]] = None,
        distinct: Optional[List[types.ApiKeyScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single ApiKey record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            ApiKey filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ApiKey model
        order
            Order the returned ApiKey records by any field
        distinct
            Filter ApiKey records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.ApiKey
            The first ApiKey record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second ApiKey record ordered by the permissions field
        apikey = await ApiKey.prisma().find_first(
            skip=1,
            order={
                'permissions': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ApiKeyWhereInput] = None,
        cursor: Optional[types.ApiKeyWhereUniqueInput] = None,
        include: Optional[types.ApiKeyInclude] = None,
        order: Optional[Union[types.ApiKeyOrderByInput, List[types.ApiKeyOrderByInput]]] = None,
        distinct: Optional[List[types.ApiKeyScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single ApiKey record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            ApiKey filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ApiKey model
        order
            Order the returned ApiKey records by any field
        distinct
            Filter ApiKey records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.ApiKey
            The first ApiKey record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second ApiKey record ordered by the isActive field
        apikey = await ApiKey.prisma().find_first_or_raise(
            skip=1,
            order={
                'isActive': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.ApiKeyUpdateInput,
        where: types.ApiKeyWhereUniqueInput,
        include: Optional[types.ApiKeyInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single ApiKey record.

        Parameters
        ----------
        data
            ApiKey record data specifying what to update
        where
            ApiKey filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned ApiKey model

        Returns
        -------
        prisma.models.ApiKey
            The updated ApiKey record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        apikey = await ApiKey.prisma().update(
            where={
                'id': 'hfcfhhadh',
            },
            data={
                # data to update the ApiKey record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.ApiKeyWhereUniqueInput,
        data: types.ApiKeyUpsertInput,
        include: Optional[types.ApiKeyInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            ApiKey filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned ApiKey model

        Returns
        -------
        prisma.models.ApiKey
            The created or updated ApiKey record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        apikey = await ApiKey.prisma().upsert(
            where={
                'id': 'bbihggdcji',
            },
            data={
                'create': {
                    'id': 'bbihggdcji',
                    'name': 'fejggijff',
                    'keyHash': 'hghjaaai',
                    'permissions': Json({'cajicjjdef': True}),
                },
                'update': {
                    'name': 'fejggijff',
                    'keyHash': 'hghjaaai',
                    'permissions': Json({'cajicjjdef': True}),
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.ApiKeyUpdateManyMutationInput,
        where: types.ApiKeyWhereInput,
    ) -> int:
        """Update multiple ApiKey records

        Parameters
        ----------
        data
            ApiKey data to update the selected ApiKey records to
        where
            Filter to select the ApiKey records to update

        Returns
        -------
        int
            The total number of ApiKey records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all ApiKey records
        total = await ApiKey.prisma().update_many(
            data={
                'lastUsedAt': datetime.datetime.utcnow()
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ApiKeyWhereInput] = None,
        cursor: Optional[types.ApiKeyWhereUniqueInput] = None,
    ) -> int:
        """Count the number of ApiKey records present in the database

        Parameters
        ----------
        select
            Select the ApiKey fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            ApiKey filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ApiKeyCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await ApiKey.prisma().count()

        # results: prisma.types.ApiKeyCountAggregateOutput
        results = await ApiKey.prisma().count(
            select={
                '_all': True,
                'expiresAt': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.ApiKeyCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ApiKeyWhereInput] = None,
        cursor: Optional[types.ApiKeyWhereUniqueInput] = None,
    ) -> types.ApiKeyCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.ApiKeyCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ApiKeyWhereInput] = None,
        cursor: Optional[types.ApiKeyWhereUniqueInput] = None,
    ) -> Union[int, types.ApiKeyCountAggregateOutput]:
        """Count the number of ApiKey records present in the database

        Parameters
        ----------
        select
            Select the ApiKey fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            ApiKey filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ApiKeyCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await ApiKey.prisma().count()

        # results: prisma.types.ApiKeyCountAggregateOutput
        results = await ApiKey.prisma().count(
            select={
                '_all': True,
                'createdAt': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.ApiKeyCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.ApiKeyWhereInput] = None
    ) -> int:
        """Delete multiple ApiKey records.

        Parameters
        ----------
        where
            Optional ApiKey filter to find the records to be deleted

        Returns
        -------
        int
            The total number of ApiKey records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all ApiKey records
        total = await ApiKey.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.ApiKeyScalarFieldKeys'],
        *,
        where: Optional['types.ApiKeyWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.ApiKeyAvgAggregateInput'] = None,
        sum: Optional['types.ApiKeySumAggregateInput'] = None,
        min: Optional['types.ApiKeyMinAggregateInput'] = None,
        max: Optional['types.ApiKeyMaxAggregateInput'] = None,
        having: Optional['types.ApiKeyScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.ApiKeyCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.ApiKeyScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.ApiKeyScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.ApiKeyGroupByOutput']:
        """Group ApiKey records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar ApiKey fields to group records by
        where
            ApiKey filter to select records
        take
            Limit the maximum number of ApiKey records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.ApiKeyGroupByOutput]
            A list of dictionaries representing the ApiKey record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group ApiKey records by updatedAt values
        # and count how many records are in each group
        results = await ApiKey.prisma().group_by(
            ['updatedAt'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class RateLimitActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.RateLimit]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await RateLimit.prisma().query_raw(
            'SELECT * FROM RateLimit WHERE id = $1',
            'hgjgibdgd',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.RateLimit
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await RateLimit.prisma().query_first(
            'SELECT * FROM RateLimit WHERE identifier = $1',
            'bcbecjfice',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.RateLimitCreateInput,
        include: Optional[types.RateLimitInclude] = None
    ) -> _PrismaModelT:
        """Create a new RateLimit record.

        Parameters
        ----------
        data
            RateLimit record data
        include
            Specifies which relations should be loaded on the returned RateLimit model

        Returns
        -------
        prisma.models.RateLimit
            The created RateLimit record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a RateLimit record from just the required fields
        ratelimit = await RateLimit.prisma().create(
            data={
                # data to create a RateLimit record
                'identifier': 'bacbebhjjd',
                'endpoint': 'dfbfaddhe',
                'windowStart': datetime.datetime.utcnow(),
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.RateLimitCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple RateLimit records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of RateLimit record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await RateLimit.prisma().create_many(
            data=[
                {
                    # data to create a RateLimit record
                    'identifier': 'bdcbbieibf',
                    'endpoint': 'dgjhdcggi',
                    'windowStart': datetime.datetime.utcnow(),
                },
                {
                    # data to create a RateLimit record
                    'identifier': 'bbjbcdfabd',
                    'endpoint': 'gchfgbcec',
                    'windowStart': datetime.datetime.utcnow(),
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.RateLimitWhereUniqueInput,
        include: Optional[types.RateLimitInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single RateLimit record.

        Parameters
        ----------
        where
            RateLimit filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned RateLimit model

        Returns
        -------
        prisma.models.RateLimit
            The deleted RateLimit record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        ratelimit = await RateLimit.prisma().delete(
            where={
                'id': 'bihcjfcjah',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.RateLimitWhereUniqueInput,
        include: Optional[types.RateLimitInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique RateLimit record.

        Parameters
        ----------
        where
            RateLimit filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned RateLimit model

        Returns
        -------
        prisma.models.RateLimit
            The found RateLimit record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        ratelimit = await RateLimit.prisma().find_unique(
            where={
                'id': 'bhjdcicaii',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.RateLimitWhereUniqueInput,
        include: Optional[types.RateLimitInclude] = None
    ) -> _PrismaModelT:
        """Find a unique RateLimit record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            RateLimit filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned RateLimit model

        Returns
        -------
        prisma.models.RateLimit
            The found RateLimit record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        ratelimit = await RateLimit.prisma().find_unique_or_raise(
            where={
                'id': 'bibedjhcej',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.RateLimitWhereInput] = None,
        cursor: Optional[types.RateLimitWhereUniqueInput] = None,
        include: Optional[types.RateLimitInclude] = None,
        order: Optional[Union[types.RateLimitOrderByInput, List[types.RateLimitOrderByInput]]] = None,
        distinct: Optional[List[types.RateLimitScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple RateLimit records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of RateLimit records returned
        skip
            Ignore the first N results
        where
            RateLimit filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned RateLimit model
        order
            Order the returned RateLimit records by any field
        distinct
            Filter RateLimit records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.RateLimit]
            The list of all RateLimit records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 RateLimit records
        ratelimits = await RateLimit.prisma().find_many(take=10)

        # find the first 5 RateLimit records ordered by the endpoint field
        ratelimits = await RateLimit.prisma().find_many(
            take=5,
            order={
                'endpoint': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.RateLimitWhereInput] = None,
        cursor: Optional[types.RateLimitWhereUniqueInput] = None,
        include: Optional[types.RateLimitInclude] = None,
        order: Optional[Union[types.RateLimitOrderByInput, List[types.RateLimitOrderByInput]]] = None,
        distinct: Optional[List[types.RateLimitScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single RateLimit record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            RateLimit filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned RateLimit model
        order
            Order the returned RateLimit records by any field
        distinct
            Filter RateLimit records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.RateLimit
            The first RateLimit record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second RateLimit record ordered by the requestCount field
        ratelimit = await RateLimit.prisma().find_first(
            skip=1,
            order={
                'requestCount': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.RateLimitWhereInput] = None,
        cursor: Optional[types.RateLimitWhereUniqueInput] = None,
        include: Optional[types.RateLimitInclude] = None,
        order: Optional[Union[types.RateLimitOrderByInput, List[types.RateLimitOrderByInput]]] = None,
        distinct: Optional[List[types.RateLimitScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single RateLimit record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            RateLimit filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned RateLimit model
        order
            Order the returned RateLimit records by any field
        distinct
            Filter RateLimit records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.RateLimit
            The first RateLimit record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second RateLimit record ordered by the windowStart field
        ratelimit = await RateLimit.prisma().find_first_or_raise(
            skip=1,
            order={
                'windowStart': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.RateLimitUpdateInput,
        where: types.RateLimitWhereUniqueInput,
        include: Optional[types.RateLimitInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single RateLimit record.

        Parameters
        ----------
        data
            RateLimit record data specifying what to update
        where
            RateLimit filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned RateLimit model

        Returns
        -------
        prisma.models.RateLimit
            The updated RateLimit record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        ratelimit = await RateLimit.prisma().update(
            where={
                'id': 'bjcdajabfa',
            },
            data={
                # data to update the RateLimit record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.RateLimitWhereUniqueInput,
        data: types.RateLimitUpsertInput,
        include: Optional[types.RateLimitInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            RateLimit filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned RateLimit model

        Returns
        -------
        prisma.models.RateLimit
            The created or updated RateLimit record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        ratelimit = await RateLimit.prisma().upsert(
            where={
                'id': 'bchhceeeff',
            },
            data={
                'create': {
                    'id': 'bchhceeeff',
                    'identifier': 'bbjbcdfabd',
                    'endpoint': 'gchfgbcec',
                    'windowStart': datetime.datetime.utcnow(),
                },
                'update': {
                    'identifier': 'bbjbcdfabd',
                    'endpoint': 'gchfgbcec',
                    'windowStart': datetime.datetime.utcnow(),
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.RateLimitUpdateManyMutationInput,
        where: types.RateLimitWhereInput,
    ) -> int:
        """Update multiple RateLimit records

        Parameters
        ----------
        data
            RateLimit data to update the selected RateLimit records to
        where
            Filter to select the RateLimit records to update

        Returns
        -------
        int
            The total number of RateLimit records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all RateLimit records
        total = await RateLimit.prisma().update_many(
            data={
                'createdAt': datetime.datetime.utcnow()
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.RateLimitWhereInput] = None,
        cursor: Optional[types.RateLimitWhereUniqueInput] = None,
    ) -> int:
        """Count the number of RateLimit records present in the database

        Parameters
        ----------
        select
            Select the RateLimit fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            RateLimit filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.RateLimitCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await RateLimit.prisma().count()

        # results: prisma.types.RateLimitCountAggregateOutput
        results = await RateLimit.prisma().count(
            select={
                '_all': True,
                'updatedAt': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.RateLimitCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.RateLimitWhereInput] = None,
        cursor: Optional[types.RateLimitWhereUniqueInput] = None,
    ) -> types.RateLimitCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.RateLimitCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.RateLimitWhereInput] = None,
        cursor: Optional[types.RateLimitWhereUniqueInput] = None,
    ) -> Union[int, types.RateLimitCountAggregateOutput]:
        """Count the number of RateLimit records present in the database

        Parameters
        ----------
        select
            Select the RateLimit fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            RateLimit filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.RateLimitCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await RateLimit.prisma().count()

        # results: prisma.types.RateLimitCountAggregateOutput
        results = await RateLimit.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.RateLimitCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.RateLimitWhereInput] = None
    ) -> int:
        """Delete multiple RateLimit records.

        Parameters
        ----------
        where
            Optional RateLimit filter to find the records to be deleted

        Returns
        -------
        int
            The total number of RateLimit records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all RateLimit records
        total = await RateLimit.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.RateLimitScalarFieldKeys'],
        *,
        where: Optional['types.RateLimitWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.RateLimitAvgAggregateInput'] = None,
        sum: Optional['types.RateLimitSumAggregateInput'] = None,
        min: Optional['types.RateLimitMinAggregateInput'] = None,
        max: Optional['types.RateLimitMaxAggregateInput'] = None,
        having: Optional['types.RateLimitScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.RateLimitCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.RateLimitScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.RateLimitScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.RateLimitGroupByOutput']:
        """Group RateLimit records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar RateLimit fields to group records by
        where
            RateLimit filter to select records
        take
            Limit the maximum number of RateLimit records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.RateLimitGroupByOutput]
            A list of dictionaries representing the RateLimit record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group RateLimit records by identifier values
        # and count how many records are in each group
        results = await RateLimit.prisma().group_by(
            ['identifier'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]



def _select_fields(root: str, select: Mapping[str, Any]) -> str:
    """Helper to build a GraphQL selection string

    This is a work around until field selection is added to the query builder.
    """

    return root + ' {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))


from . import models